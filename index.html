<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">

    <!-- ── SEO ─────────────────────────────────────────────────────── -->
    <title>VocabLoop – 智能英语单词记忆 | 间隔重复闪卡 · PET / 口语 / 加密</title>
    <meta name="description" content="VocabLoop 是基于间隔重复算法的英语词汇学习 PWA，涵盖 PET 考试词汇、日常口语短语、网络缩写和加密金融术语。支持离线使用、真人发音、学习进度追踪。">
    <meta name="keywords" content="英语单词,间隔重复,闪卡,PET词汇,英语学习,口语短语,vocabulary,flashcard,spaced repetition,英语背单词">
    <meta name="author" content="VocabLoop">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="./">

    <!-- ── PWA / Home Screen ────────────────────────────────────────── -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a3a5c">
    <meta name="mobile-web-app-capable" content="yes">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="VocabLoop">
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32.png">

    <!-- ── Open Graph (Facebook / WeChat / Slack 等预览) ─────────────── -->
    <meta property="og:type"        content="website">
    <meta property="og:site_name"   content="VocabLoop">
    <meta property="og:url"         content="./">
    <meta property="og:title"       content="VocabLoop – 智能英语单词记忆">
    <meta property="og:description" content="基于间隔重复算法的英语词汇 PWA，PET 考试 · 日常口语 · 加密金融词汇，支持离线与真人发音。">
    <meta property="og:image"       content="icons/icon-512.png">
    <meta property="og:image:width"  content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:type"   content="image/png">
    <meta property="og:image:alt"   content="VocabLoop 图标 – 蓝色背景白色 V 字母与循环箭头">
    <meta property="og:locale"      content="zh_CN">

    <!-- ── Twitter / X Card ────────────────────────────────────────── -->
    <meta name="twitter:card"        content="summary">
    <meta name="twitter:title"       content="VocabLoop – 智能英语单词记忆">
    <meta name="twitter:description" content="间隔重复闪卡 PWA，PET 考试 · 日常口语 · 加密词汇，随时随地背单词。">
    <meta name="twitter:image"       content="icons/icon-512.png">

    <!-- ── JSON-LD 结构化数据 ─────────────────────────────────────────── -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "VocabLoop",
      "url": "./",
      "description": "基于间隔重复算法的英语词汇学习 PWA，涵盖 PET 考试词汇、日常口语短语和加密金融术语，支持离线使用与真人发音。",
      "applicationCategory": "EducationApplication",
      "operatingSystem": "Web, iOS, Android",
      "inLanguage": ["zh-CN", "en"],
      "isAccessibleForFree": true,
      "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" },
      "image": "icons/icon-512.png",
      "featureList": ["间隔重复算法", "PET词汇", "日常口语短语", "网络缩写", "加密金融词汇", "离线PWA", "真人发音"]
    }
    </script>

    <!-- ── SEO 域名自适配：根据当前 URL 自动更新 canonical / OG / Twitter 等 meta ── -->
    <script>
    (function(){
      var base = location.origin + location.pathname.replace(/[^/]*$/, '');
      var icon = base + 'icons/icon-512.png';
      function setMeta(sel, attr, val){
        var el = document.querySelector(sel);
        if(el) el.setAttribute(attr, val);
      }
      setMeta('link[rel="canonical"]',      'href',    base);
      setMeta('meta[property="og:url"]',     'content', base);
      setMeta('meta[property="og:image"]',   'content', icon);
      setMeta('meta[name="twitter:image"]',  'content', icon);
      // Update JSON-LD
      var ld = document.querySelector('script[type="application/ld+json"]');
      if(ld){
        try{
          var data = JSON.parse(ld.textContent);
          data.url = base; data.image = icon;
          ld.textContent = JSON.stringify(data);
        }catch(_){}
      }
    })();
    </script>

    <!-- ── 性能预连接 ─────────────────────────────────────────────────── -->
    <link rel="preconnect" href="https://api.dictionaryapi.dev">
    <link rel="preconnect" href="https://dict.youdao.com">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">

    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        /* Hide raw template until Vue mounts — prevents {{mustache}} flash */
        [v-cloak] { display: none !important; }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg: #f0f4f9;
            --surface: #fff;
            --border: #e2e8f0;
            --text: #1e2533;
            --muted: #7a8299;
            --blue: #3b82f6;
            --green: #22c55e;
            --amber: #f59e0b;
            --red: #ef4444;
            --purple: #8b5cf6;
            --card-back: #1a3a5c;
            --r: 16px;
        }

        html, body { height: 100%; touch-action: manipulation; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC',
                         'Microsoft YaHei', 'Segoe UI', Roboto, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            /* home indicator / gesture bar on iPhone X+ and Android */
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* ── Safe-area padding (iOS notch / Android cutout / home indicator) ── */
        /* env() falls back to 0 on desktop, so this is safe everywhere        */
        .hd {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            /* top padding absorbs status-bar height on both iOS & Android */
            padding: calc(10px + env(safe-area-inset-top)) 14px 0;
            display: flex;
            flex-direction: column;
        }
        /* Row 1: title + action buttons — never wraps */
        .hd-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding-bottom: 12px;
        }
        .hd-title {
            font-size: 1rem;
            font-weight: 800;
            color: var(--blue);
            white-space: nowrap;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* Row 2: stats chips — always one line, scrollable */
        .chips {
            display: flex;
            gap: 5px;
            overflow-x: auto;
            flex-wrap: nowrap;
            padding: 6px 0 14px;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        .chips::-webkit-scrollbar { display: none; }
        .chip {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 4px 10px;
            border-radius: 99px;
            font-size: 0.75rem;
            font-weight: 700;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .chip-new    { background: #dbeafe; color: #1d4ed8; }
        .chip-learn  { background: #fef3c7; color: #92400e; }
        .chip-review { background: #d1fae5; color: #065f46; }
        .chip-master { background: #ede9fe; color: #5b21b6; }
        .chip-streak { background: #ffe4e6; color: #be123c; }
        .chip-daily  { background: #fff7ed; color: #c2410c; }
        .level-badge {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--muted);
            white-space: nowrap;
        }
        .hd-btns { display: flex; gap: 6px; align-items: center; overflow-x: auto; flex-shrink: 1; min-width: 0; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .hd-btns::-webkit-scrollbar { display: none; }
        .btn-hd {
            background: none;
            border: 1px solid var(--border);
            padding: 5px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.78rem;
            color: var(--muted);
            transition: all 0.15s;
            white-space: nowrap;
        }
        .btn-hd:hover { border-color: var(--blue); color: var(--blue); }
        .btn-hd.active { border-color: var(--blue); background: var(--blue); color: #fff; }
        .btn-hd.danger:hover { border-color: var(--red); color: var(--red); }

        /* ── Mode bar (below card) ───────────── */
        .mode-bar {
            display: flex; gap: 8px;
            justify-content: center;
            padding: 8px 14px 2px;
            flex-shrink: 0;
        }
        .mode-btn {
            background: none;
            border: 1.5px solid var(--border);
            border-radius: 99px;
            padding: 5px 16px;
            font-size: 0.78rem; font-weight: 600;
            color: var(--muted); cursor: pointer;
            transition: all 0.15s;
        }
        .mode-btn:hover { border-color: var(--blue); color: var(--blue); }
        .mode-btn.active {
            border-color: var(--blue); color: var(--blue);
            background: rgba(59,130,246,.08);
        }
        .mode-btn-play.active {
            border-color: #8b5cf6; color: #8b5cf6;
            background: rgba(139,92,246,.08);
        }

        /* ── Deck selector bar ───────────────── */
        .deck-bar {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 6px 14px;
            display: flex;
            gap: 8px;
            overflow-x: auto;
            scrollbar-width: none;
            -webkit-overflow-scrolling: touch;
        }
        .deck-bar::-webkit-scrollbar { display: none; }
        .deck-btn {
            background: none;
            border: 1.5px solid var(--border);
            padding: 5px 14px;
            border-radius: 99px;
            cursor: pointer;
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--muted);
            white-space: nowrap;
            transition: all 0.15s;
            flex-shrink: 0;
        }
        .deck-btn:hover { border-color: var(--blue); color: var(--blue); }
        .deck-btn.active { border-color: var(--blue); color: var(--blue); background: #eff6ff; }

        /* ── Loading ─────────────────────────── */
        .loading-scr {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 14px;
            color: var(--muted);
        }
        .spinner {
            width: 36px; height: 36px;
            border: 3px solid var(--border);
            border-top-color: var(--blue);
            border-radius: 50%;
            animation: spin 0.75s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ── Done screen ─────────────────────── */
        .done-scr {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 28px 20px 36px;
            gap: 18px;
            overflow-y: auto;
        }
        .done-header   { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .done-emoji    { font-size: 3.6rem; line-height: 1; }
        .done-title    { font-size: 1.65rem; font-weight: 800; }
        .done-subtitle { font-size: 0.84rem; color: var(--muted); margin-top: 2px; }
        .done-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 100%;
            max-width: 380px;
            background: var(--border);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border);
        }
        .done-stat {
            display: flex; flex-direction: column; align-items: center; gap: 3px;
            background: var(--surface); padding: 14px 8px;
        }
        .done-stat-val   { font-size: 1.8rem; font-weight: 800; color: var(--blue); line-height: 1.1; }
        .done-stat-label { font-size: 0.68rem; color: var(--muted); }
        .done-meta-row {
            display: flex; align-items: center; gap: 8px;
            flex-wrap: wrap; justify-content: center;
        }
        .done-forecast {
            font-size: 0.8rem;
            color: var(--muted);
            text-align: center;
            padding: 6px 16px;
            background: var(--bg);
            border-radius: 99px;
            border: 1px solid var(--border);
        }
        .done-level        { font-size: 0.88rem; color: var(--purple); font-weight: 700; }
        .done-achievements { font-size: 1.05rem; letter-spacing: 2px; }
        /* Action cards */
        .done-actions {
            display: flex; flex-direction: column; gap: 10px;
            width: 100%; max-width: 380px;
        }
        .done-action {
            display: flex; align-items: center; gap: 14px;
            padding: 15px 18px; border-radius: 14px;
            border: none; cursor: pointer; text-align: left; width: 100%;
            transition: transform 0.1s, box-shadow 0.15s;
        }
        .done-action:active { transform: scale(0.98) !important; box-shadow: none !important; }
        .done-action-icon  { font-size: 1.55rem; flex-shrink: 0; line-height: 1; }
        .done-action-text  { flex: 1; display: flex; flex-direction: column; gap: 2px; }
        .done-action-title { font-size: 0.95rem; font-weight: 700; line-height: 1.2; }
        .done-action-hint  { font-size: 0.75rem; opacity: 0.78; line-height: 1.3; }
        .done-action-arrow { font-size: 1rem; flex-shrink: 0; opacity: 0.65; }
        .done-action-primary {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: #fff;
            box-shadow: 0 4px 18px rgba(139,92,246,0.38);
        }
        .done-action-primary:hover  { box-shadow: 0 6px 24px rgba(139,92,246,0.52); transform: translateY(-1px); }
        .done-action-secondary {
            background: linear-gradient(135deg, #10b981, #059669);
            color: #fff;
            box-shadow: 0 4px 18px rgba(16,185,129,0.32);
        }
        .done-action-secondary:hover { box-shadow: 0 6px 24px rgba(16,185,129,0.44); transform: translateY(-1px); }
        .done-action-tertiary {
            background: var(--surface); color: var(--text);
            border: 1.5px solid var(--border);
        }
        .done-action-tertiary .done-action-arrow { color: var(--muted); opacity: 1; }
        .done-action-tertiary:hover { border-color: var(--blue); }
        .done-share-pill {
            display: flex; align-items: center; justify-content: center; gap: 7px;
            padding: 9px 22px; border-radius: 99px;
            border: 1.5px solid var(--border); color: var(--muted); background: transparent;
            font-size: 0.84rem; font-weight: 600; cursor: pointer;
            transition: border-color 0.15s, color 0.15s;
        }
        .done-share-pill:hover  { border-color: var(--blue); color: var(--blue); }
        .done-share-pill:active { transform: scale(0.97); }
        .share-svg { vertical-align: middle; flex-shrink: 0; }
        /* ── Sync button ── */
        .sync-svg { vertical-align: middle; flex-shrink: 0; transition: transform .3s; }
        .btn-hd.syncing .sync-svg { animation: syncSpin .8s linear infinite; }
        .btn-hd.sync-ok { border-color: var(--green) !important; color: var(--green) !important; }
        @keyframes syncSpin { to { transform: rotate(360deg); } }
        /* Practice done footer buttons */
        .prac-done-footer { display: flex; gap: 10px; width: 100%; margin-top: 4px; }
        .prac-foot-share {
            flex: 1; display: flex; align-items: center; justify-content: center; gap: 6px;
            padding: 13px; border-radius: 12px;
            border: 1.5px solid var(--border); color: var(--muted); background: transparent;
            font-size: 0.9rem; font-weight: 600; cursor: pointer;
            transition: border-color 0.15s, color 0.15s;
        }
        .prac-foot-share:hover { border-color: var(--blue); color: var(--blue); }
        .prac-foot-back {
            flex: 2;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: #fff; border: none;
            padding: 13px; border-radius: 12px;
            font-size: 0.95rem; font-weight: 700; cursor: pointer;
            box-shadow: 0 4px 16px rgba(59,130,246,0.32);
            transition: box-shadow 0.15s, transform 0.1s;
        }
        .prac-foot-back:hover  { box-shadow: 0 6px 22px rgba(59,130,246,0.42); transform: translateY(-1px); }
        .prac-foot-back:active { transform: scale(0.97); box-shadow: none; }

        /* ── Card area ───────────────────────── */
        .card-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 14px 14px 18px;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        /* ── List view ───────────────────────── */
        .wl-wrap { width: 100%; overflow-y: auto; flex: 1; }
        .wl-section { margin-bottom: 20px; }
        .wl-section-title {
            font-size: .69rem; font-weight: 700; color: var(--muted);
            text-transform: uppercase; letter-spacing: .08em;
            padding: 0 2px 7px; border-bottom: 1px solid var(--border);
        }
        .wl-row {
            padding: 9px 6px; border-radius: 8px; cursor: pointer;
            transition: background .12s;
            border-bottom: 1px solid var(--border);
        }
        .wl-row:last-child { border-bottom: none; }
        .wl-row:hover { background: rgba(59,130,246,.06); }
        .wl-row.open {
            background: var(--surface); border-bottom-color: transparent;
            margin-bottom: 3px; box-shadow: 0 1px 4px rgba(0,0,0,.07);
        }
        .wl-row-head { display: flex; align-items: center; gap: 9px; }
        .wl-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
        .wl-dot-new    { background: #22c55e; }
        .wl-dot-learn  { background: #f97316; }
        .wl-dot-review { background: #3b82f6; }
        .wl-word { font-weight: 700; color: var(--text); flex-shrink: 0; min-width: 76px; font-size: .9rem; }
        .wl-zh-short { flex: 1; color: var(--muted); font-size: .82rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .wl-chevron { color: #c0c8d8; font-size: .78rem; flex-shrink: 0; transition: transform .2s; line-height: 1; }
        .wl-row.open .wl-chevron { transform: rotate(90deg); color: var(--blue); }
        .wl-detail {
            margin-top: 8px; padding: 9px 10px; border-radius: 7px;
            background: #f0f4f9;
            display: flex; flex-wrap: wrap; align-items: center; gap: 5px 10px;
        }
        .wl-ipa { font-family: 'SF Mono', Menlo, monospace; color: var(--muted); font-size: .78rem; }
        .wl-pos-badge {
            background: #dbeafe; border-radius: 4px;
            padding: 1px 7px; font-size: .7rem; color: #1d4ed8; font-weight: 600;
        }
        .wl-zh-full { color: var(--text); font-size: .88rem; width: 100%; margin-top: 2px; font-weight: 500; }
        .wl-example-text { color: var(--muted); font-size: .76rem; font-style: italic; width: 100%; margin-top: 4px; }

        /* progress */
        .prog-row {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 14px;
        }
        .prog-track {
            flex: 1; height: 10px;
            background: var(--border);
            border-radius: 99px;
            overflow: hidden;
        }
        .prog-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--blue));
            border-radius: 99px;
            transition: width 0.5s cubic-bezier(.4,0,.2,1);
        }
        .prog-text {
            font-size: 0.76rem;
            color: var(--muted);
            min-width: 46px;
            text-align: right;
            white-space: nowrap;
        }

        /* card wrapper */
        .card-wrap {
            width: 100%;
            perspective: 1400px;
            margin-bottom: 20px;
        }
        .card-wrap.shaking  { animation: do-shake  0.45s ease; }
        .card-wrap.bouncing { animation: do-bounce 0.35s ease; }

        @keyframes do-shake {
            0%,100% { transform: translateX(0); }
            15%     { transform: translateX(-8px); }
            30%     { transform: translateX(8px); }
            50%     { transform: translateX(-5px); }
            70%     { transform: translateX(5px); }
            85%     { transform: translateX(-2px); }
        }
        @keyframes do-bounce {
            0%,100% { transform: scale(1); }
            40%     { transform: scale(1.045); }
            70%     { transform: scale(0.985); }
        }

        .card {
            position: relative;
            width: 100%;
            height: 320px;
            transform-style: preserve-3d;
            transition: transform 0.5s cubic-bezier(.4,0,.2,1);
            cursor: pointer;
            outline: none;
        }
        .card.flipped { transform: rotateY(180deg); }
        .card:focus-visible {
            outline: 2px solid var(--blue);
            outline-offset: 4px;
            border-radius: var(--r);
        }

        .face {
            position: absolute; inset: 0;
            backface-visibility: hidden;
            border-radius: var(--r);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 22px 20px 20px;
            box-shadow: 0 12px 40px rgba(30,64,175,0.13), 0 2px 8px rgba(0,0,0,0.07);
        }
        .face.front {
            background: linear-gradient(160deg, #ffffff 0%, #f0f5ff 100%);
            border: 1px solid rgba(59,130,246,0.10);
        }
        .face.back  {
            background: linear-gradient(148deg, #1e4480 0%, #0c1f3d 100%);
            color: #fff;
            transform: rotateY(180deg);
        }

        /* front face elements */
        .pos-tag {
            position: absolute; top: 12px; right: 12px;
            background: #eef2fb; color: var(--blue);
            font-size: 0.66rem; font-weight: 700;
            text-transform: uppercase;
            padding: 2px 8px; border-radius: 99px;
        }
        /* Stage badge on card front — helps user know what type of card they're reviewing */
        .front-stage {
            position: absolute; top: 12px; left: 12px;
            font-size: 0.62rem; font-weight: 700;
            padding: 2px 7px; border-radius: 99px;
        }
        .fs-learning{ background: #fef9c3; color: #854d0e; }
        .fs-young   { background: #dcfce7; color: #14532d; }
        .fs-mature  { background: #ede9fe; color: #4c1d95; }
        .fs-relearn { background: #fee2e2; color: #b91c1c; }
        .front-word {
            font-size: 2.6rem;
            font-weight: 800;
            letter-spacing: -0.5px;
            text-align: center;
            line-height: 1.1;
            color: #1a2540;
        }
        .front-ipa {
            font-size: 0.9rem;
            color: var(--muted);
            margin-top: 6px;
            letter-spacing: 0.03em;
            min-height: 1.3em;
        }
        .front-ipa.fetching {
            color: #ccd;
            animation: blink 1.4s ease-in-out infinite;
        }
        @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
        .audio-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            background: none;
            border: 1.5px solid var(--border);
            border-radius: 99px;
            padding: 6px 18px;
            margin-top: 12px;
            cursor: pointer;
            font-size: 0.84rem;
            color: var(--muted);
            transition: border-color 0.15s, color 0.15s, background 0.15s;
            min-height: 36px;
        }
        .audio-btn:hover { border-color: var(--blue); color: var(--blue); }
        .audio-btn.playing {
            border-color: var(--green);
            color: var(--green);
            background: #f0fdf4;
        }
        .front-hint {
            position: absolute; bottom: 13px;
            font-size: 0.72rem; color: #c0c8d8;
        }

        /* back face elements */
        .stage-tag {
            position: absolute; top: 12px; left: 12px;
            font-size: 0.66rem; font-weight: 700;
            padding: 2px 8px; border-radius: 99px;
        }
        .st-new     { background: rgba(59,130,246,.25);  color: #93c5fd; }
        .st-learning{ background: rgba(245,158,11,.25);  color: #fcd34d; }
        .st-young   { background: rgba(34,197,94,.25);   color: #86efac; }
        .st-mature  { background: rgba(139,92,246,.25);  color: #c4b5fd; }
        .st-relearn { background: rgba(239,68,68,.25);   color: #fca5a5; }

        /* ── Card back layout ──────────────────────────────────── */
        /* ① word + IPA inline header */
        .back-header {
            display: flex; align-items: baseline;
            justify-content: center; gap: 8px;
            margin-bottom: 2px;
        }
        .back-word {
            font-size: 1.05rem; font-weight: 700;
            color: rgba(255,255,255,.72);
            letter-spacing: 0.04em;
        }
        .back-ipa {
            font-family: 'SF Mono', 'Fira Mono', Menlo, monospace;
            font-size: 0.76rem;
            color: rgba(255,255,255,.4);
            letter-spacing: 0.02em;
        }
        /* ② full form (abbreviations) */
        .back-fullform {
            font-size: 0.76rem;
            color: rgba(255,255,255,.42);
            text-align: center;
            margin-bottom: 6px;
            letter-spacing: 0.01em;
            padding: 0 12px;
        }
        /* ③ Chinese meaning — hero */
        .back-zh {
            font-size: 2.1rem; font-weight: 800;
            text-align: center; line-height: 1.2;
            margin-top: 2px; margin-bottom: 8px;
        }
        /* ④ pos badge + English definition — same row */
        .back-def-row {
            display: flex; align-items: flex-start;
            justify-content: center; flex-wrap: wrap;
            gap: 6px; padding: 0 16px;
        }
        .back-pos {
            display: inline-flex; align-items: center;
            background: rgba(255,255,255,.14);
            border-radius: 99px; padding: 2px 9px;
            font-size: 0.7rem; font-weight: 700;
            letter-spacing: 0.02em; flex-shrink: 0;
            margin-top: 1px;
        }
        .back-def {
            font-size: 0.75rem;
            color: rgba(255,255,255,.5);
            font-style: italic;
            text-align: left; line-height: 1.45;
            display: -webkit-box;
            -webkit-line-clamp: 2; line-clamp: 2;
            -webkit-box-orient: vertical; overflow: hidden;
        }
        /* ⑤ example sentences with separator */
        .back-examples {
            width: 100%;
            border-top: 1px solid rgba(255,255,255,.1);
            margin-top: 12px; padding-top: 10px;
            display: flex; flex-direction: column; gap: 6px;
            padding-left: 8px; padding-right: 8px;
        }
        .back-example {
            font-size: 0.79rem;
            color: rgba(255,255,255,.7);
            font-style: italic; text-align: center;
            display: -webkit-box;
            -webkit-line-clamp: 2; line-clamp: 2;
            -webkit-box-orient: vertical; overflow: hidden;
            line-height: 1.5;
        }
        .back-example2 {
            font-size: 0.73rem;
            color: rgba(255,255,255,.45);
            font-style: italic; text-align: center;
            display: -webkit-box;
            -webkit-line-clamp: 2; line-clamp: 2;
            -webkit-box-orient: vertical; overflow: hidden;
            line-height: 1.5;
        }
        .back-note {
            font-size: 0.64rem; color: rgba(255,255,255,.38);
            text-align: center; margin-top: 4px;
            padding: 0 12px; line-height: 1.4;
        }

        /* controls */
        .controls {
            position: absolute;
            top: 0; left: 0; right: 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: opacity .2s;
        }
        .controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .cb {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 6px;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            font-weight: 700;
            gap: 4px;
            transition: transform 0.12s, box-shadow 0.12s;
            min-height: 64px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }
        .cb:hover  { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.10); }
        .cb:active { transform: scale(0.93); box-shadow: none; }
        .cb-again { background: #fee2e2; color: #b91c1c; }
        .cb-hard  { background: #fef9c3; color: #854d0e; }
        .cb-good  { background: #dcfce7; color: #14532d; }
        .cb-easy  { background: #ede9fe; color: #4c1d95; }
        .cb-label    { font-size: 0.9rem; }
        .cb-interval { font-size: 0.68rem; opacity: 0.7; }

        .controls-wrap {
            position: relative;
            width: 100%;
            height: 88px;       /* fixed: cb 64px + padding 12px×2 — never changes */
            overflow: hidden;
            flex-shrink: 0;
        }
        .key-hint {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--muted);
            font-size: 0.76rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity .2s;
        }
        .key-hint.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* toast */
        .toast-anchor {
            position: fixed;
            /* Push well below header + deck-bar on all devices (incl. iPhone safe-area) */
            top: calc(170px + env(safe-area-inset-top, 0px));
            left: 50%;
            transform: translateX(-50%);
            z-index: 300;
            pointer-events: none;
        }
        .toast {
            padding: 8px 22px;
            border-radius: 99px;
            font-weight: 700;
            font-size: 0.88rem;
            color: #fff;
            white-space: nowrap;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }
        .t-good  { background: var(--green); }
        .t-bad   { background: var(--red); }
        .t-bonus { background: var(--purple); }

        .toast-enter-active, .toast-leave-active { transition: opacity .25s, transform .25s; }
        .toast-enter    { opacity: 0; transform: translateY(-8px); }
        .toast-leave-to { opacity: 0; transform: translateY(-8px); }


        /* footer */
        .ft {
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 8px 16px;
            text-align: center;
        }
        .ft-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.78rem;
            color: var(--muted);
            margin-bottom: 6px;
        }
        .ft-row strong { color: var(--text); }
        .xp-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .xp-label {
            font-size: 0.68rem;
            color: var(--muted);
            white-space: nowrap;
        }
        .xp-track {
            flex: 1;
            height: 8px;
            background: var(--border);
            border-radius: 99px;
            overflow: hidden;
        }
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--purple), var(--blue));
            border-radius: 99px;
            transition: width 0.6s cubic-bezier(.4,0,.2,1);
        }
        .xp-next {
            font-size: 0.68rem;
            color: var(--muted);
            white-space: nowrap;
        }

        /* ── Force-refresh button ────────────────────────── */
        #upd-zone {
            padding: 16px 0 max(22px, env(safe-area-inset-bottom));
            text-align: center;
        }
        .brand-tagline {
            margin-top: 10px;
            font-size: 0.64rem;
            color: var(--muted);
            opacity: 0.45;
            letter-spacing: 0.04em;
        }
        #upd-btn {
            background: transparent;
            border: 1.5px solid var(--border);
            border-radius: 99px;
            padding: 5px 14px 5px 10px;
            font-size: 0.72rem;
            color: var(--muted);
            cursor: pointer;
            opacity: 0.35;
            transition: opacity 0.25s, border-color 0.25s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        #upd-btn:hover  { opacity: 1; border-color: var(--blue); color: var(--blue); }
        #upd-btn:active { opacity: 1; }
        .upd-ring { font-size: 0.9rem; display: inline-block; }
        #upd-btn.upd-go .upd-ring  { animation: updSpin 0.55s linear infinite; }
        #upd-btn.upd-blast         { animation: updBlast 0.4s ease-in forwards; pointer-events: none; }
        @keyframes updSpin  { to { transform: rotate(360deg); } }
        @keyframes updBlast {
            0%   { opacity: 1; transform: scale(1)    translateY(0); }
            55%  { opacity: 1; transform: scale(1.18) translateY(-10px); }
            100% { opacity: 0; transform: scale(0.15) translateY(-60px); }
        }

        /* ── Dark mode ────────────────────────────────────── */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --surface: #1e293b;
                --border: #334155;
                --text: #e2e8f0;
                --muted: #94a3b8;
                --blue: #60a5fa;
                --green: #4ade80;
                --amber: #fbbf24;
                --red: #f87171;
                --purple: #a78bfa;
            }
            /* Card front */
            .face.front {
                background: linear-gradient(160deg, #1e293b 0%, #0f1e3c 100%);
                border-color: rgba(96,165,250,0.12);
            }
            .front-word { color: #e2e8f0; }
            .pos-tag    { background: #1e3658; color: #60a5fa; }
            .fs-learning{ background: #3b2d0a; color: #fbbf24; }
            .fs-young   { background: #0a2b18; color: #4ade80; }
            .fs-mature  { background: #221940; color: #a78bfa; }
            .fs-relearn { background: #3b1212; color: #f87171; }
            /* Answer buttons */
            .cb-again { background: #3b1515; color: #f87171; }
            .cb-hard  { background: #3b2d0a; color: #fbbf24; }
            .cb-good  { background: #0a2b18; color: #4ade80; }
            .cb-easy  { background: #1e1040; color: #a78bfa; }
            /* Header chips */
            .chip-new    { background: #1a2d4a; color: #93c5fd; }
            .chip-learn  { background: #3b2d0a; color: #fcd34d; }
            .chip-review { background: #0a2b18; color: #6ee7b7; }
            .chip-master { background: #221940; color: #c4b5fd; }
            .chip-streak { background: #3b1520; color: #fda4af; }
            .chip-daily  { background: #3b200a; color: #fdba74; }
            /* Practice */
            .prac-card         { background: #1e293b; border-color: #334155; }
            .prac-opt          { background: #1e293b; border-color: #334155; color: #e2e8f0; }
            .prac-opt:hover:not(:disabled) { background: #1e3050; border-color: #60a5fa; }
            .prac-spell-input  { background: #0f172a; border-color: #334155; color: #e2e8f0; }
            .prac-tf-btn       { background: #1e293b; border-color: #334155; color: #e2e8f0; }
            .prac-match-item   { background: #1e293b; border-color: #334155; color: #e2e8f0; }
            .prac-match-item.sel { background: #1e3258; color: #60a5fa; }
            /* Done screen */
            .done-stat         { background: #1e293b; }
            .done-action-tertiary { background: #1e293b; border-color: #334155; color: #e2e8f0; }
            /* Word list */
            .wl-detail         { background: #0f172a; }
            .wl-row:hover      { background: rgba(96,165,250,.08); }
            .wl-row.open       { background: #1e293b; }
            .wl-pos-badge      { background: #1e3658; color: #93c5fd; }
            /* Reading overlay */
            .reading-overlay   { background: #0f172a; }
            .reading-hd        { background: #1e293b; border-bottom-color: #334155; }
            .reading-key-box   { background: #1e293b; border-color: #334155; }
            .reading-hist-item { background: #1e293b; border-color: #334155; }
            /* Footer / header */
            .hd, .deck-bar, .ft { background: #1e293b; border-color: #334155; }
            .xp-track          { background: #334155; }
            /* Loading screen */
            .loading-scr       { background: var(--bg); }
        }

        /* ── Small mobile (≤ 390px) ──────────────────────── */
        @media (max-width: 390px) {
            .hd         { padding: calc(6px + env(safe-area-inset-top)) 10px 0; }
            .hd-top     { padding-bottom: 6px; }
            .hd-title   { font-size: 0.9rem; }
            .chip       { font-size: 0.68rem; padding: 2px 6px; }
            .level-badge{ font-size: 0.7rem; }
            .btn-hd     { padding: 2px 7px; font-size: 0.72rem; }
            .deck-btn   { font-size: 0.75rem; padding: 4px 10px; }
            .card       { height: 292px; }
            .front-word { font-size: 2.1rem; }
            .back-zh    { font-size: 1.75rem; }
            .cb         { min-height: 56px; padding: 10px 4px; border-radius: 14px; }
            .cb-label   { font-size: 0.8rem; }
            .cb-interval{ font-size: 0.62rem; }
            .controls   { gap: 7px; }
            .controls-wrap { height: 76px; }   /* 56px + 10px×2 */
            .card-area  { padding: 10px 10px 14px; }
            .back-example{ font-size: 0.74rem; }
            .done-stat-val { font-size: 1.8rem; }
        }

        /* ── Regular mobile (391–599px) ──────────────────── */
        @media (min-width: 391px) and (max-width: 599px) {
            .card { height: 308px; }
        }

        /* ── Tablet / iPad (≥ 600px) ─────────────────────── */
        @media (min-width: 600px) {
            .card-area  { max-width: 680px; }
            .card       { height: 350px; }
            .front-word { font-size: 3rem; }
            .back-zh    { font-size: 2.4rem; }
            .back-example { font-size: 0.85rem; }
            .cb         { padding: 14px 10px; min-height: 72px; border-radius: 18px; }
            .cb-label   { font-size: 0.95rem; }
            .cb-interval{ font-size: 0.72rem; }
            .controls   { gap: 14px; }
            .controls-wrap { height: 100px; }  /* 72px + 14px×2 */
            .prog-track { height: 12px; }
            .xp-track   { height: 10px; }
            .done-stat-val { font-size: 2.5rem; }
            .done-title { font-size: 2.1rem; }
        }

        /* ── iPad Pro / Desktop (≥ 900px) ────────────────── */
        @media (min-width: 900px) {
            .card-area  { max-width: 720px; }
            .card       { height: 360px; }
            .front-word { font-size: 3.2rem; }
            .back-zh    { font-size: 2.5rem; }
        }

        /* ── Add-to-Home-Screen prompts ───────────────────────────────── */

        /* Android install banner (bottom bar) */
        #pwa-android {
            display: none;
            position: fixed;
            bottom: 0; left: 0; right: 0;
            z-index: 9999;
            padding: 12px 16px max(12px, env(safe-area-inset-bottom));
            background: #fff;
            box-shadow: 0 -4px 24px rgba(0,0,0,0.14);
            border-radius: 16px 16px 0 0;
            align-items: center;
            gap: 12px;
            animation: slideUp 0.35s ease;
        }
        #pwa-android.show { display: flex; }
        #pwa-android .pwa-icon {
            width: 48px; height: 48px; border-radius: 12px; flex-shrink: 0;
        }
        #pwa-android .pwa-text { flex: 1; }
        #pwa-android .pwa-text strong { display: block; font-size: 0.97rem; color: #1e2533; }
        #pwa-android .pwa-text span   { font-size: 0.8rem; color: #64748b; }
        #pwa-install-btn {
            padding: 9px 18px;
            background: linear-gradient(135deg,#2563EB,#6D28D9);
            color: #fff; border: none; border-radius: 20px;
            font-size: 0.9rem; font-weight: 600; cursor: pointer;
            white-space: nowrap;
        }
        #pwa-dismiss-android {
            background: none; border: none; font-size: 1.3rem; cursor: pointer;
            color: #94a3b8; padding: 4px 6px; flex-shrink: 0;
        }

        /* iOS guide overlay (full-screen) */
        #pwa-ios {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(0,0,0,0.55);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            align-items: flex-end;
            justify-content: center;
        }
        #pwa-ios.show { display: flex; animation: fadeInBg 0.3s ease; }

        #pwa-ios-card {
            background: #fff;
            border-radius: 24px 24px 0 0;
            padding: 24px 24px max(24px, env(safe-area-inset-bottom));
            width: 100%; max-width: 480px;
            animation: slideUp 0.38s cubic-bezier(0.34,1.3,0.64,1);
        }
        #pwa-ios-card .pwa-header {
            display: flex; align-items: center; gap: 14px; margin-bottom: 20px;
        }
        #pwa-ios-card .pwa-header img {
            width: 56px; height: 56px; border-radius: 14px;
            box-shadow: 0 4px 12px rgba(37,99,235,0.3);
        }
        #pwa-ios-card .pwa-header-text h3 {
            font-size: 1.1rem; font-weight: 700; color: #1e2533;
        }
        #pwa-ios-card .pwa-header-text p {
            font-size: 0.82rem; color: #64748b; margin-top: 2px;
        }
        #pwa-ios-card .pwa-steps {
            background: #f8faff; border-radius: 16px;
            padding: 16px 18px; margin-bottom: 18px;
        }
        #pwa-ios-card .pwa-step {
            display: flex; align-items: center; gap: 12px;
            padding: 10px 0;
        }
        #pwa-ios-card .pwa-step + .pwa-step {
            border-top: 1px solid #e9eef6;
        }
        #pwa-ios-card .step-num {
            width: 28px; height: 28px; border-radius: 50%;
            background: linear-gradient(135deg,#2563EB,#6D28D9);
            color: #fff; font-size: 0.82rem; font-weight: 700;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
        }
        #pwa-ios-card .step-text { font-size: 0.9rem; color: #2d3748; line-height: 1.4; }
        #pwa-ios-card .step-text em { font-style: normal; font-weight: 600; color: #2563EB; }
        #pwa-ios-card .step-icon {
            margin-left: auto; font-size: 1.3rem; flex-shrink: 0;
        }
        #pwa-dismiss-ios {
            width: 100%;
            padding: 13px;
            background: #f1f5f9; border: none; border-radius: 14px;
            color: #475569; font-size: 0.95rem; font-weight: 600;
            cursor: pointer;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to   { transform: translateY(0);    opacity: 1; }
        }
        @keyframes fadeInBg {
            from { opacity: 0; }
            to   { opacity: 1; }
        }

        /* ── Practice Mode ───────────────────────────────────────────────── */
        .prac-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 14px 14px 18px;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
            gap: 14px;
        }

        /* Progress bar row */
        .prac-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        .prac-prog-track {
            flex: 1; height: 10px;
            background: var(--border);
            border-radius: 99px;
            overflow: hidden;
        }
        .prac-prog-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--purple), var(--blue));
            border-radius: 99px;
            transition: width 0.4s ease;
        }
        .prac-prog-text { font-size: 0.76rem; color: var(--muted); min-width: 40px; text-align: right; white-space: nowrap; }
        .prac-score     { font-size: 0.76rem; font-weight: 700; color: var(--purple); min-width: 36px; text-align: right; white-space: nowrap; }

        /* Question card */
        .prac-card {
            width: 100%;
            background: var(--surface);
            border-radius: var(--r);
            padding: 26px 20px 22px;
            box-shadow: 0 12px 40px rgba(30,64,175,0.13), 0 2px 8px rgba(0,0,0,0.07);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            border: 1px solid var(--border);
            text-align: center;
            min-height: 160px;
        }
        .prac-type-label {
            font-size: 0.68rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.07em;
            color: var(--muted);
            opacity: 0.75;
        }
        .prac-word {
            font-size: 2.4rem;
            font-weight: 800;
            color: #1a2540;
            letter-spacing: -0.5px;
            line-height: 1.1;
        }
        .prac-zh       { font-size: 1.4rem; font-weight: 700; color: var(--text); line-height: 1.3; }
        .prac-ipa      { font-size: 0.9rem; color: var(--muted); }
        .prac-example  { font-size: 0.8rem; color: var(--muted); font-style: italic; max-width: 92%; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .prac-hint     { font-size: 0.84rem; color: var(--muted); }
        .prac-partial  { font-family: 'SF Mono', Menlo, monospace; font-size: 1.1rem; color: var(--blue); letter-spacing: 3px; font-weight: 700; }
        .prac-audio-prompt { margin: 6px 0; }
        .prac-zh-hint  { font-size: 1rem; color: var(--muted); font-weight: 600; }

        /* True/False pair display */
        .prac-tf-pair  { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .prac-tf-eq    { font-size: 1.4rem; color: var(--muted); font-weight: 300; line-height: 1; }

        /* Multiple-choice options */
        .prac-options  { width: 100%; display: flex; flex-direction: column; gap: 10px; }
        .prac-opt {
            width: 100%;
            padding: 14px 16px;
            border-radius: 12px;
            border: 1.5px solid var(--border);
            background: var(--surface);
            font-size: 0.94rem;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
            text-align: left;
            transition: border-color 0.15s, background 0.15s, transform 0.1s;
            line-height: 1.35;
        }
        .prac-opt:hover:not(:disabled) { border-color: var(--blue); background: #eff6ff; }
        .prac-opt:active:not(:disabled) { transform: scale(0.98); }
        .prac-opt:disabled { cursor: default; }
        .prac-opt:focus, .prac-opt:focus-visible { outline: none; box-shadow: none; border-color: var(--border); background: var(--surface); }
        .prac-opt { display: flex; justify-content: space-between; align-items: center; -webkit-tap-highlight-color: transparent; }
        .prac-opt.correct  { border-color: var(--green) !important; background: #f0fdf4 !important; color: #14532d !important; animation: prac-pop 0.32s ease; }
        .prac-opt.wrong    { border-color: var(--red)   !important; background: #fef2f2 !important; color: #b91c1c !important; animation: prac-shake 0.32s ease; }
        .prac-opt-icon { font-size: 1rem; font-weight: 800; flex-shrink: 0; margin-left: 8px; }

        /* True/False buttons */
        .prac-tf-btns { width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .prac-tf-btn {
            padding: 16px 10px;
            border-radius: 14px;
            border: 1.5px solid var(--border);
            background: var(--surface);
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s;
        }
        .prac-tf-true  { color: #14532d; }
        .prac-tf-false { color: #b91c1c; }
        .prac-tf-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.10); }
        .prac-tf-btn:active:not(:disabled){ transform: scale(0.97); }
        .prac-tf-btn:disabled { cursor: default; transform: none; box-shadow: none; }
        .prac-tf-btn:focus, .prac-tf-btn:focus-visible { outline: none; box-shadow: none; border-color: var(--border); background: var(--surface); }
        .prac-tf-btn { display: flex; align-items: center; justify-content: center; gap: 8px; -webkit-tap-highlight-color: transparent; }
        .prac-tf-btn.correct { border-color: var(--green) !important; background: #f0fdf4 !important; color: #14532d !important; animation: prac-pop 0.32s ease; }
        .prac-tf-btn.wrong   { border-color: var(--red)   !important; background: #fef2f2 !important; color: #b91c1c !important; animation: prac-shake 0.32s ease; }
        /* On touch-only devices, suppress sticky :hover after tap */
        @media (hover: none) {
            .prac-opt:hover:not(:disabled)    { border-color: var(--border); background: var(--surface); }
            .prac-tf-btn:hover:not(:disabled) { border-color: var(--border); background: var(--surface); transform: none; box-shadow: none; }
        }

        /* Spelling */
        .prac-spell-wrap {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
        }
        .prac-spell-input {
            width: 100%;
            padding: 14px 16px;
            border-radius: 12px;
            border: 1.5px solid var(--border);
            font-size: 1.1rem;
            font-weight: 600;
            outline: none;
            transition: border-color 0.15s;
            text-align: center;
            letter-spacing: 0.05em;
            font-family: inherit;
        }
        .prac-spell-input:focus  { border-color: var(--blue); }
        .prac-spell-input.correct{ border-color: var(--green); background: #f0fdf4; }
        .prac-spell-input.wrong  { border-color: var(--red);   background: #fef2f2; }
        .prac-spell-input:disabled { cursor: default; }
        .prac-submit-btn {
            padding: 12px;
            background: linear-gradient(135deg, var(--blue), #1d4ed8);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-size: 0.94rem;
            font-weight: 700;
            cursor: pointer;
            transition: opacity 0.15s, transform 0.1s;
        }
        .prac-submit-btn:active { opacity: 0.85; transform: scale(0.97); }
        .prac-correct-ans { font-size: 0.86rem; color: var(--muted); text-align: center; }
        .prac-correct-ans strong { color: var(--green); }

        /* Card slide transition */
        .prac-q-enter-active { transition: opacity 0.22s ease, transform 0.22s ease; }
        .prac-q-leave-active { transition: opacity 0.15s ease, transform 0.15s ease; }
        .prac-q-enter        { opacity: 0; transform: translateX(28px); }
        .prac-q-leave-to     { opacity: 0; transform: translateX(-20px); }

        /* Correct/wrong micro-animations */
        @keyframes prac-pop {
            0%   { transform: scale(1); }
            45%  { transform: scale(1.04); }
            100% { transform: scale(1); }
        }
        @keyframes prac-shake {
            0%, 100% { transform: translateX(0); }
            25%       { transform: translateX(-5px); }
            75%       { transform: translateX(5px); }
        }

        /* Practice done screen */
        .prac-done {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 16px;
            padding: 24px 20px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        /* Practice done — score hero */
        .prac-done-hero { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
        .prac-score-display { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .prac-score-pct { font-size: 3.8rem; font-weight: 900; line-height: 1; letter-spacing: -0.03em; }
        .pct-green { color: var(--green); }
        .pct-amber { color: var(--amber); }
        .pct-red   { color: var(--red);   }
        .prac-score-emoji { font-size: 1.6rem; }
        .prac-done-title { font-size: 1.5rem; font-weight: 800; }
        .prac-done-bar-wrap { width: 100%; max-width: 280px; background: var(--border); border-radius: 99px; height: 8px; overflow: hidden; }
        .prac-done-bar-fill { height: 100%; border-radius: 99px; background: linear-gradient(90deg, var(--green), var(--blue)); transition: width 0.9s cubic-bezier(.4,0,.2,1); }
        .prac-done-chips { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; justify-content: center; }
        .pdc { font-size: 0.88rem; font-weight: 700; }
        .pdc-good  { color: var(--green); }
        .pdc-bad   { color: var(--red); }
        .pdc-sep   { color: var(--border); font-weight: 400; }
        .pdc-total { color: var(--muted); font-weight: 400; font-size: 0.82rem; }
        /* Practice done — review cards */
        .prac-review-section { width: 100%; text-align: left; border-top: 1px solid var(--border); padding-top: 16px; }
        .prac-review-hd { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
        .prac-review-hd-text { font-size: 0.76rem; font-weight: 700; color: var(--muted); text-transform: uppercase; letter-spacing: 0.07em; }
        .prac-review-hd-count { font-size: 0.76rem; font-weight: 700; background: var(--border); color: var(--muted); padding: 1px 7px; border-radius: 99px; }
        .prac-review-card { padding: 12px 0; border-bottom: 1px solid var(--border); display: flex; flex-direction: column; gap: 4px; }
        .prac-review-card:last-child { border-bottom: none; }
        .prac-review-top { display: flex; align-items: baseline; gap: 6px; flex-wrap: wrap; }
        .prac-review-word { font-size: 1rem; font-weight: 700; color: var(--text); }
        .prac-review-pos  { font-size: 0.7rem; color: var(--muted); background: var(--bg); border: 1px solid var(--border); border-radius: 4px; padding: 1px 5px; }
        .prac-review-ipa  { font-size: 0.78rem; color: var(--muted); font-style: italic; }
        .prac-review-zh   { font-size: 0.88rem; color: var(--blue); }
        .prac-review-ex   { font-size: 0.8rem; color: var(--muted); line-height: 1.5; font-style: italic; }
        /* ── Matching question ─────────────────────────────────────────── */
        .prac-match-wrap { width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .prac-match-col  { display: flex; flex-direction: column; gap: 8px; }
        .prac-match-item {
            width: 100%; min-height: 48px; padding: 10px 8px;
            border-radius: 10px; border: 1.5px solid var(--border);
            background: var(--surface); color: var(--text);
            font-size: 0.85rem; font-weight: 600; cursor: pointer;
            text-align: center; line-height: 1.3;
            transition: border-color 0.15s, background 0.15s, opacity 0.35s;
            -webkit-tap-highlight-color: transparent;
        }
        .prac-match-item:hover:not(:disabled)  { border-color: var(--blue); background: #eff6ff; }
        .prac-match-item:focus, .prac-match-item:focus-visible { outline: none; box-shadow: none; }
        .prac-match-item.sel  { border-color: var(--blue); background: #dbeafe; color: var(--blue); }
        .prac-match-item.elim { opacity: 0.22; cursor: default; border-color: var(--green); background: #f0fdf4; pointer-events: none; }
        .prac-match-item.shake { animation: prac-shake 0.35s ease; border-color: var(--red) !important; background: #fef2f2 !important; }

        /* Practice start button (done screen + header) */
        .btn-practice {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: #fff;
            border: none;
            padding: 12px 30px;
            border-radius: 14px;
            font-size: 0.92rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(139,92,246,0.35);
            transition: box-shadow 0.15s, transform 0.1s;
        }
        .btn-practice:hover  { box-shadow: 0 6px 22px rgba(139,92,246,0.45); transform: translateY(-1px); }
        .btn-practice:active { transform: scale(0.97); box-shadow: none; }

        /* ── Reading overlay ───────────────────────────────────────── */
        .reading-overlay {
            position: fixed; inset: 0; z-index: 200;
            background: var(--bg);
            display: flex; flex-direction: column;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            animation: rdSlideUp 0.28s cubic-bezier(.32,.72,0,1);
        }
        @keyframes rdSlideUp {
            from { transform: translateY(60px); opacity: 0; }
            to   { transform: translateY(0);    opacity: 1; }
        }
        .reading-hd {
            display: flex; align-items: center; justify-content: space-between;
            padding: 14px 18px; border-bottom: 1px solid var(--border); flex-shrink: 0;
        }
        .reading-hd-title { font-size: 1rem; font-weight: 700; }
        .reading-close {
            background: none; border: none; font-size: 1.35rem;
            cursor: pointer; color: var(--muted); padding: 4px 8px; line-height: 1;
        }
        .reading-body {
            flex: 1; overflow-y: auto; padding: 20px 18px 28px;
            -webkit-overflow-scrolling: touch;
            display: flex; flex-direction: column; gap: 18px;
        }
        .reading-key-box {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 14px; padding: 18px 16px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .reading-key-info { font-size: 0.88rem; color: var(--muted); line-height: 1.5; }
        .reading-key-link { color: var(--blue); text-decoration: none; font-size: 0.85rem; }
        .reading-key-row { display: flex; gap: 8px; }
        .reading-key-input {
            flex: 1; padding: 11px 14px; border: 1.5px solid var(--border);
            border-radius: 10px; font-size: 0.88rem; outline: none;
            font-family: 'SF Mono', monospace; background: var(--bg); color: var(--text);
            letter-spacing: 0.02em;
        }
        .reading-key-input:focus { border-color: var(--blue); }
        .reading-key-save {
            padding: 11px 16px; background: var(--blue); color: #fff;
            border: none; border-radius: 10px; font-weight: 700;
            cursor: pointer; white-space: nowrap; font-size: 0.9rem;
        }
        .reading-loading {
            display: flex; flex-direction: column; align-items: center;
            gap: 10px; padding: 48px 0; text-align: center;
        }
        .reading-spinner {
            width: 28px; height: 28px; border: 3px solid var(--border);
            border-top-color: var(--blue); border-radius: 50%;
            animation: spin 0.7s linear infinite; margin-bottom: 4px;
        }
        .reading-loading-main { font-size: 0.95rem; font-weight: 600; color: var(--text); }
        .reading-loading-sub  { font-size: 0.82rem; color: var(--muted); }
        .reading-key-area {
            display: flex; flex-direction: column; align-items: center;
            gap: 12px; padding: 32px 16px; text-align: center;
        }
        .reading-key-info { font-size: 0.92rem; color: var(--text); font-weight: 600; }
        .reading-key-link { font-size: 0.82rem; color: var(--blue); text-decoration: none; }
        .reading-key-link:hover { text-decoration: underline; }
        .reading-key-input {
            width: 100%; max-width: 320px; padding: 9px 12px;
            border: 1.5px solid var(--border); border-radius: 8px;
            background: var(--card); color: var(--text);
            font-size: 0.85rem; outline: none; box-sizing: border-box;
        }
        .reading-key-input:focus { border-color: var(--blue); }
        .reading-key-save {
            padding: 9px 22px; border-radius: 8px; border: none; cursor: pointer;
            background: var(--blue); color: #fff; font-size: 0.9rem; font-weight: 600;
        }
        .reading-key-save:hover { opacity: 0.88; }
        .reading-key-area .reading-key-row {
            display: flex; gap: 8px; align-items: center; width: 100%; max-width: 340px;
        }
        .reading-key-paste {
            flex-shrink: 0; padding: 9px 12px; border-radius: 8px;
            border: 1.5px solid var(--border); background: var(--card);
            color: var(--text); cursor: pointer; font-size: 1rem; line-height: 1;
        }
        .reading-key-paste:hover { border-color: var(--blue); }
        .reading-key-steps { display: flex; flex-direction: column; gap: 8px; width: 100%; max-width: 340px; }
        .reading-key-step {
            display: flex; align-items: center; gap: 9px;
            font-size: 0.83rem; color: var(--muted); margin: 0;
        }
        .reading-key-num {
            width: 20px; height: 20px; border-radius: 50%; background: var(--blue); color: #fff;
            font-size: 0.72rem; font-weight: 700; display: flex; align-items: center;
            justify-content: center; flex-shrink: 0;
        }
        .reading-key-cta {
            display: inline-block; padding: 8px 16px; margin-left: 29px;
            background: var(--blue); color: #fff; border-radius: 9px;
            text-decoration: none; font-size: 0.85rem; font-weight: 600;
        }
        .reading-key-cta:hover { opacity: 0.88; }
        /* History */
        .reading-hist-btn {
            background: none; border: none; cursor: pointer;
            color: var(--muted); font-size: 0.8rem; padding: 4px 9px;
            border-radius: 6px; white-space: nowrap;
        }
        .reading-hist-btn:hover  { background: var(--surface); color: var(--text); }
        .reading-hist-btn.active { color: var(--blue); }
        .reading-hist-empty {
            text-align: center; color: var(--muted); font-size: 0.88rem; padding: 48px 0;
        }
        .reading-hist-item {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 12px; padding: 14px 16px; cursor: pointer;
            transition: border-color 0.15s;
        }
        .reading-hist-item:hover { border-color: var(--blue); }
        .reading-hist-meta {
            display: flex; align-items: center; gap: 7px; margin-bottom: 7px;
        }
        .reading-hist-date   { font-size: 0.77rem; color: var(--muted); }
        .reading-hist-deck   {
            font-size: 0.7rem; background: var(--blue); color: #fff;
            padding: 1px 7px; border-radius: 20px; font-weight: 700;
        }
        .reading-hist-wcount { font-size: 0.77rem; color: var(--muted); margin-left: auto; }
        .reading-hist-preview {
            font-size: 0.85rem; color: var(--text); line-height: 1.55;
            overflow: hidden; display: -webkit-box;
            -webkit-line-clamp: 2; -webkit-box-orient: vertical;
        }
        .reading-error {
            display: flex; flex-direction: column; align-items: center;
            gap: 8px; padding: 40px 0; text-align: center;
        }
        .reading-error-icon { font-size: 2.2rem; line-height: 1; }
        .reading-error-msg  { font-size: 0.9rem; color: var(--red); line-height: 1.5; max-width: 280px; }
        .reading-article {
            font-size: 1rem; line-height: 1.95; color: var(--text); white-space: pre-wrap;
        }
        .vocab-hl {
            font-weight: 800;
            color: var(--blue);
            font-style: normal;
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
        }
        .reading-word-list {
            padding-top: 16px; border-top: 1px solid var(--border);
            font-size: 0.82rem; color: var(--muted); line-height: 1.9;
        }
        .reading-word-list strong { color: var(--text); }
        .reading-regen {
            width: 100%; padding: 13px; border: 1.5px solid var(--blue);
            color: var(--blue); background: none; border-radius: 12px;
            font-weight: 700; cursor: pointer; font-size: 0.9rem;
        }
        .btn-reading {
            width: 100%; padding: 14px;
            background: linear-gradient(135deg, #059669, #047857);
            color: #fff; border: none; border-radius: 14px;
            font-size: 0.95rem; font-weight: 700; cursor: pointer; margin-top: 4px;
            box-shadow: 0 4px 16px rgba(5,150,105,0.3);
            transition: box-shadow 0.15s, transform 0.1s;
        }
        .btn-reading:hover  { box-shadow: 0 6px 22px rgba(5,150,105,0.4); transform: translateY(-1px); }
        .btn-reading:active { transform: scale(0.97); box-shadow: none; }

        /* ── Responsive adjustments for practice ─────────────── */
        @media (max-width: 390px) {
            .prac-area     { padding: 10px 10px 14px; gap: 10px; }
            .prac-word     { font-size: 1.9rem; }
            .prac-zh       { font-size: 1.2rem; }
            .prac-opt      { font-size: 0.85rem; padding: 11px 12px; }
            .prac-tf-btn   { font-size: 0.9rem; padding: 13px 8px; }
            .prac-card     { padding: 20px 14px 16px; gap: 8px; }
        }
        /* ── Undo button (floats briefly after each SRS answer) ────────────── */
        .undo-btn {
            position: fixed;
            bottom: calc(72px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            z-index: 250;
            background: rgba(120,130,150,0.28);
            color: rgba(255,255,255,0.55);
            border: 1px solid rgba(255,255,255,0.10);
            padding: 6px 16px;
            border-radius: 99px;
            font-size: 0.78rem;
            font-weight: 400;
            cursor: pointer;
            white-space: nowrap;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            box-shadow: none;
            pointer-events: auto;
        }
        .undo-btn:hover  { background: rgba(120,130,150,0.45); color: rgba(255,255,255,0.8); }
        .undo-btn:active { transform: translateX(-50%) scale(0.96); }

        /* ── Practice exit button (in progress row) ─────────────────────── */
        .prac-exit-btn {
            background: none; border: none; cursor: pointer;
            color: var(--muted); font-size: 1.1rem; padding: 2px 4px;
            line-height: 1; flex-shrink: 0; border-radius: 6px;
            transition: color 0.15s;
        }
        .prac-exit-btn:hover { color: var(--red); }

        /* ── Clickable chips ─────────────────────────────────────────────── */
        .chip-btn {
            cursor: pointer;
            border: none;
            transition: filter 0.15s, transform 0.1s;
        }
        .chip-btn:hover  { filter: brightness(0.93); }
        .chip-btn:active { transform: scale(0.95); }
        /* Number pop when chip value changes (no out-in: old disappears instantly, new pops) */
        .chip-num-enter-active { animation: chipPop 0.38s ease-out; }
        .chip-num-leave-active { display: none; }
        @keyframes chipPop {
            0%   { transform: scale(0.7); opacity: 0; }
            60%  { transform: scale(1.4); opacity: 1; }
            100% { transform: scale(1);   opacity: 1; }
        }

        /* ── Onboarding overlay ─────────────────────────────────────────── */
        .ob-overlay {
            position: fixed; inset: 0; z-index: 400;
            background: var(--bg);
            display: flex; flex-direction: column;
            padding-top: env(safe-area-inset-top);
            animation: rdSlideUp 0.32s cubic-bezier(.32,.72,0,1);
        }
        .ob-hd {
            display: flex; align-items: center; justify-content: flex-end;
            padding: 10px 16px; flex-shrink: 0;
        }
        .ob-skip {
            background: none; border: none; font-size: 0.8rem; font-weight: 600;
            color: var(--muted); cursor: pointer; padding: 6px 10px;
            border-radius: 8px; transition: color 0.15s;
        }
        .ob-skip:hover { color: var(--text); }
        .ob-body {
            flex: 1; overflow-y: auto; padding: 0 20px 20px;
            -webkit-overflow-scrolling: touch;
            display: flex; flex-direction: column; gap: 28px;
        }
        .ob-hero {
            display: flex; flex-direction: column; align-items: center;
            text-align: center; gap: 8px; padding: 16px 0 8px;
        }
        .ob-logo    { width: 80px; height: 80px; border-radius: 20px; object-fit: cover; box-shadow: 0 4px 16px rgba(0,0,0,0.12); }
        .ob-brand   { font-size: 2rem; font-weight: 900; color: var(--text); letter-spacing: -0.02em; }
        .ob-tagline { font-size: 0.85rem; color: var(--muted); }
        .ob-section { display: flex; flex-direction: column; gap: 12px; }
        .ob-section-title {
            font-size: 1rem; font-weight: 800; color: var(--text);
            padding-bottom: 6px; border-bottom: 2px solid var(--border);
        }
        .ob-section-body { font-size: 0.88rem; color: var(--muted); line-height: 1.65; }
        .ob-decks { display: flex; flex-direction: column; gap: 10px; }
        .ob-deck {
            display: flex; align-items: flex-start; gap: 14px;
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 14px; padding: 14px 16px;
        }
        .ob-deck-icon { font-size: 1.6rem; line-height: 1; flex-shrink: 0; margin-top: 2px; }
        .ob-deck-name { font-size: 0.95rem; font-weight: 700; color: var(--text); }
        .ob-deck-desc { font-size: 0.8rem; color: var(--muted); margin-top: 3px; line-height: 1.5; }
        .ob-steps { display: flex; flex-direction: column; gap: 12px; }
        .ob-step  {
            display: flex; align-items: flex-start; gap: 12px;
            font-size: 0.88rem; color: var(--muted); line-height: 1.55;
        }
        .ob-step-num {
            width: 22px; height: 22px; border-radius: 50%;
            background: var(--blue); color: #fff;
            font-size: 0.75rem; font-weight: 700;
            display: flex; align-items: center; justify-content: center; flex-shrink: 0;
            margin-top: 1px;
        }
        .ob-footer {
            flex-shrink: 0;
            padding: 12px 20px calc(12px + env(safe-area-inset-bottom));
            border-top: 1px solid var(--border); background: var(--bg);
        }
        .ob-cta {
            width: 100%; padding: 16px;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: #fff; border: none; border-radius: 16px;
            font-size: 1.05rem; font-weight: 800; cursor: pointer;
            box-shadow: 0 4px 20px rgba(139,92,246,0.38);
            transition: transform 0.1s, box-shadow 0.15s;
        }
        .ob-cta:hover  { transform: translateY(-1px); box-shadow: 0 6px 26px rgba(139,92,246,0.48); }
        .ob-cta:active { transform: scale(0.98); box-shadow: none; }
        /* ob-panel fills overlay on mobile */
        .ob-panel {
            display: flex; flex-direction: column;
            flex: 1; width: 100%; overflow: hidden;
        }
        /* Large screen: centered card modal */
        @media (min-width: 700px) {
            .ob-overlay {
                align-items: center; justify-content: center;
                background: rgba(15,23,42,0.55);
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                animation: none;
                padding-top: 0;
            }
            .ob-panel {
                flex: none;
                width: 100%; max-width: 560px;
                max-height: 85vh;
                background: var(--bg);
                border-radius: 24px;
                overflow: hidden;
                box-shadow: 0 24px 64px rgba(0,0,0,0.28);
                animation: rdSlideUp 0.32s cubic-bezier(.32,.72,0,1);
            }
            .ob-footer {
                padding-bottom: 20px;
            }
            .ob-decks {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            .ob-deck {
                flex-direction: column; gap: 8px;
                align-items: flex-start;
            }
        }

        /* ── Daily Welcome ───────────────────────────────────────────────── */
        .dw-overlay {
            position: fixed; inset: 0; z-index: 410;
            display: flex; align-items: center; justify-content: center;
            background: rgba(15,23,42,0.52);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            padding: 24px 20px;
            animation: fadeIn 0.22s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .dw-card {
            width: 100%; max-width: 400px;
            background: var(--bg);
            border-radius: 24px;
            padding: 28px 24px 22px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.26);
            position: relative;
            animation: scaleIn 0.28s cubic-bezier(.32,.72,0,1);
        }
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.92) translateY(14px); }
            to   { opacity: 1; transform: scale(1)    translateY(0);    }
        }
        .dw-close {
            position: absolute; top: 16px; right: 16px;
            background: none; border: none;
            font-size: 0.82rem; color: var(--muted); cursor: pointer;
            padding: 4px 8px; border-radius: 6px; transition: color 0.15s;
        }
        .dw-close:hover { color: var(--text); }
        .dw-streak { text-align: center; padding: 4px 0 18px; }
        .dw-streak-emoji { font-size: 2.8rem; line-height: 1; margin-bottom: 10px; }
        .dw-streak-num {
            font-size: 2.2rem; font-weight: 900; color: var(--text);
            letter-spacing: -0.03em; line-height: 1;
        }
        .dw-streak-sub {
            font-size: 0.88rem; color: var(--muted); margin-top: 8px; line-height: 1.45;
        }
        .dw-divider { height: 1px; background: var(--border); margin: 0 0 18px; }
        .dw-quote-wrap { padding: 0 2px 20px; }
        .dw-quote-text {
            font-size: 0.9rem; color: var(--text); line-height: 1.65;
            font-style: italic; letter-spacing: 0.01em;
        }
        .dw-quote-author {
            font-size: 0.78rem; color: var(--muted); margin-top: 10px;
            text-align: right; font-weight: 600;
        }
        .dw-cta {
            width: 100%; padding: 14px;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: #fff; border: none; border-radius: 14px;
            font-size: 0.95rem; font-weight: 800; cursor: pointer;
            box-shadow: 0 4px 16px rgba(139,92,246,0.35);
            transition: transform 0.1s, box-shadow 0.15s;
        }
        .dw-cta:hover  { transform: translateY(-1px); box-shadow: 0 6px 22px rgba(139,92,246,0.45); }
        .dw-cta:active { transform: scale(0.98); box-shadow: none; }

        /* ── Word list modal ─────────────────────────────────────────────── */
        .wl-overlay {
            position: fixed; inset: 0; z-index: 500;
            background: rgba(0,0,0,0.45);
            display: flex; align-items: flex-end;
            -webkit-backdrop-filter: blur(2px);
            backdrop-filter: blur(2px);
        }
        .wl-sheet {
            width: 100%; max-height: 82vh;
            background: var(--bg);
            border-radius: 20px 20px 0 0;
            display: flex; flex-direction: column;
            box-shadow: 0 -4px 32px rgba(0,0,0,0.18);
            overflow: hidden;
        }
        .wl-header {
            display: flex; align-items: center; gap: 10px;
            padding: 16px 18px 12px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .wl-title {
            flex: 1; font-size: 1.05rem; font-weight: 700; color: var(--text);
        }
        .wl-count {
            font-size: 0.82rem; color: var(--muted); font-weight: 600;
        }
        .wl-close {
            background: none; border: none; cursor: pointer;
            color: var(--muted); font-size: 1.25rem; padding: 2px 6px;
            line-height: 1; border-radius: 8px; transition: color 0.15s;
        }
        .wl-close:hover { color: var(--text); }
        .wl-list {
            overflow-y: auto; flex: 1;
            padding: 8px 0 env(safe-area-inset-bottom, 12px);
        }
        .wl-empty {
            text-align: center; color: var(--muted);
            padding: 40px 20px; font-size: 0.95rem;
        }
        .wl-item {
            display: flex; align-items: baseline; gap: 10px;
            padding: 10px 18px;
            border-bottom: 1px solid var(--border);
            transition: background 0.12s;
        }
        .wl-item:last-child { border-bottom: none; }
        .wl-item:hover { background: var(--surface); }
        .wl-en   { font-weight: 700; font-size: 1rem; color: var(--text); min-width: 0; }
        .wl-pos  { font-size: 0.72rem; color: var(--muted); flex-shrink: 0; }
        .wl-zh   { font-size: 0.88rem; color: var(--blue); flex: 1; min-width: 0; }
        .wl-stage-badge {
            font-size: 0.68rem; font-weight: 700; padding: 2px 7px;
            border-radius: 99px; flex-shrink: 0; white-space: nowrap;
        }
        .wl-badge-new     { background: #dbeafe; color: #1d4ed8; }
        .wl-badge-learning{ background: #fef3c7; color: #92400e; }
        .wl-badge-relearn { background: #fee2e2; color: #991b1b; }
        .wl-badge-young   { background: #d1fae5; color: #065f46; }
        .wl-badge-mature  { background: #bbf7d0; color: #14532d; }
        .wl-badge-mastered{ background: #ede9fe; color: #5b21b6; }

    </style>
</head>
<body>
<div id="app" v-cloak>

    <!-- Header -->
    <div class="hd">
        <!-- Row 1: title + action buttons -->
        <div class="hd-top">
            <div class="hd-title">{{currentDeck.icon}} {{currentDeck.name}}</div>
            <div class="hd-btns">
                <button class="btn-hd" :class="{active: autoPlay}" @click="autoPlay = !autoPlay"
                        :title="autoPlay ? ui.autoPlayOn : ui.autoPlayOff">🔊</button>
                <button class="btn-hd" :class="{active: practiceMode}"
                        @click="practiceMode ? exitPractice() : startPractice()"
                        :title="ui.practiceBtn">✏️</button>
                <button class="btn-hd" :class="{active: readingOpen}"
                        @click="readingOpen ? closeReading() : openReading()"
                        :title="ui.readingBtn">📖</button>
                <button class="btn-hd" @click="shareApp" :title="ui.shareBtn">
                    <svg class="share-svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg>
                </button>
                <button id="syncBtn" v-show="backendAvailable" class="btn-hd" onclick="window.__vocabSync && window.__vocabSync.manualSync()" :title="ui.syncBtn">
                    <svg id="syncIcon" class="sync-svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
                </button>
                <button id="accountBtn" v-show="backendAvailable" class="btn-hd" onclick="window.location.href='account.html'" title="Account">👤</button>
                <button class="btn-hd" v-show="!backendAvailable" @click="exportProgress" :title="ui.exportBtn">
                    <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </button>
                <button class="btn-hd" v-show="!backendAvailable" @click="triggerImport" :title="ui.importBtn">
                    <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                </button>
            </div>
        </div>
        <!-- Hidden file input for import -->
        <input type="file" id="importFileInput" accept=".json" style="display:none" @change="handleImportFile">
        <!-- Row 2: stats chips (horizontal scroll, always one line) -->
        <div class="chips">
            <button class="chip chip-new chip-btn"   @click="showWordList('new')"
                    :title="ui.wlNew">🆕 <transition name="chip-num"><span :key="qs.newCount">{{qs.newCount}}</span></transition></button>
            <button class="chip chip-learn chip-btn" @click="showWordList('learn')"
                    :title="ui.wlLearn">📖 <transition name="chip-num"><span :key="qs.learnCount">{{qs.learnCount}}</span></transition></button>
            <button class="chip chip-review chip-btn" @click="showWordList('review')"
                    :title="ui.wlReview">🔁 <transition name="chip-num"><span :key="qs.reviewCount">{{qs.reviewCount}}</span></transition></button>
            <button class="chip chip-master chip-btn" @click="showWordList('mastered')"
                    :title="ui.wlMastered">🏆 <transition name="chip-num"><span :key="masteredCount">{{masteredCount}}</span></transition></button>
            <span class="chip chip-streak" v-if="streak >= 3">🔥 {{streak}}</span>
            <button class="chip chip-daily chip-btn" v-if="dailyStreak >= 2" @click="openDailyWelcome">📅 {{dailyStreak}}{{ui.dayUnit}}</button>
        </div>
    </div>

    <!-- Deck Selector -->
    <div class="deck-bar">
        <button v-for="d in decks" :key="d.id"
                class="deck-btn"
                :class="{active: d.id === currentDeck.id}"
                @click="switchDeck(d)">
            {{d.icon}} {{d.name}}
        </button>
    </div>

    <!-- Loading -->
    <div v-if="loading" class="loading-scr">
        <div class="spinner"></div>
        <p>{{ui.loading}}</p>
    </div>

    <!-- ── Practice Mode ─────────────────────────────────────────────── -->
    <div v-else-if="practiceMode" class="prac-area">

        <!-- Practice done screen -->
        <div v-if="practiceDone" class="prac-done">

            <!-- Score hero -->
            <div class="prac-done-hero">
                <div class="prac-score-display">
                    <div class="prac-score-pct" :class="pctColorClass">{{pracScorePct}}%</div>
                    <div class="prac-score-emoji">{{pracScoreEmoji}}</div>
                </div>
                <div class="prac-done-title">{{ui.practiceDoneTitle}}</div>
                <div class="prac-done-bar-wrap">
                    <div class="prac-done-bar-fill" :style="{width: pracScorePct + '%'}"></div>
                </div>
                <div class="prac-done-chips">
                    <span class="pdc pdc-good">✓ {{practiceScore}}</span>
                    <span class="pdc pdc-sep">/</span>
                    <span class="pdc pdc-bad">✗ {{practiceQueue.length - practiceScore}}</span>
                    <span class="pdc pdc-total">{{ui.practiceDoneScore(practiceScore, practiceQueue.length)}}</span>
                </div>
            </div>

            <!-- Wrong words with example sentences -->
            <div v-if="practiceWrongWords.length > 0" class="prac-review-section">
                <div class="prac-review-hd">
                    <span class="prac-review-hd-text">{{ui.practiceWrongTitle}}</span>
                    <span class="prac-review-hd-count">{{practiceWrongWords.length}}</span>
                </div>
                <div class="prac-review-list">
                    <div v-for="w in practiceWrongWords" :key="w.word" class="prac-review-card">
                        <div class="prac-review-top">
                            <span class="prac-review-word">{{w.word}}</span>
                            <span v-if="w.pos" class="prac-review-pos">{{w.pos}}</span>
                            <span v-if="dictCache[w.word] && dictCache[w.word].ipa" class="prac-review-ipa">/{{dictCache[w.word].ipa}}/</span>
                        </div>
                        <div class="prac-review-zh">{{w.zh}}</div>
                        <div v-if="dictCache[w.word] && dictCache[w.word].example" class="prac-review-ex">{{dictCache[w.word].example}}</div>
                    </div>
                </div>
            </div>

            <!-- Footer buttons -->
            <div class="prac-done-footer">
                <button class="prac-foot-share" @click="sharePractice">
                    <svg class="share-svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg>
                    {{ui.shareBtn}}
                </button>
                <button class="prac-foot-back" @click="exitPractice">{{ui.practiceDoneBack}}</button>
            </div>
        </div>

        <!-- Question screen -->
        <template v-else-if="practiceCurrent">

            <!-- Progress bar (outside transition so it stays stable) -->
            <div class="prac-progress">
                <button class="prac-exit-btn" @click="exitPractice" :title="ui.practiceExitBtn">✕</button>
                <div class="prac-prog-track">
                    <div class="prac-prog-fill" :style="{width: (practiceIndex / practiceQueue.length * 100) + '%'}"></div>
                </div>
                <div class="prac-prog-text">{{practiceIndex + 1}} / {{practiceQueue.length}}</div>
                <div class="prac-score">{{practiceScore}} ⭐</div>
            </div>

            <!-- Animated question body -->
            <transition name="prac-q" mode="out-in">
            <div :key="practiceIndex" style="width:100%;display:flex;flex-direction:column;gap:14px;align-items:center;">

            <!-- Question card -->
            <div class="prac-card">
                <!-- mc-word-to-zh: show English word, pick Chinese -->
                <template v-if="practiceCurrent.type === 'mc-word-to-zh'">
                    <div class="prac-type-label">{{ui.practiceMCWordToZh}}</div>
                    <div class="prac-word">{{practiceCurrent.word.word}}</div>
                    <div class="prac-ipa" v-if="dictCache[practiceCurrent.word.word] && dictCache[practiceCurrent.word.word].ipa">
                        /{{dictCache[practiceCurrent.word.word].ipa}}/
                    </div>
                </template>

                <!-- mc-zh-to-word: show Chinese meaning, pick English word -->
                <template v-else-if="practiceCurrent.type === 'mc-zh-to-word'">
                    <div class="prac-type-label">{{ui.practiceMCZhToWord}}</div>
                    <div class="prac-zh">{{practiceCurrent.word.zh}}</div>
                </template>

                <!-- mc-audio-to-word: play audio + show Chinese hint, pick English word -->
                <template v-else-if="practiceCurrent.type === 'mc-audio-to-word'">
                    <div class="prac-type-label">{{ui.practiceMCAudioToWord}}</div>
                    <div class="prac-audio-prompt">
                        <button class="audio-btn" :class="{playing: audioPlaying}"
                                @click="playAudio(practiceCurrent.word.word)">
                            🔊 {{audioPlaying ? ui.audioPlaying : ui.practicePlayAgain}}
                        </button>
                    </div>
                    <div class="prac-zh-hint">{{practiceCurrent.word.zh}}</div>
                </template>

                <!-- spelling: show Chinese + example + partial hint, type full word -->
                <template v-else-if="practiceCurrent.type === 'spelling'">
                    <div class="prac-type-label">{{ui.practiceSpelling}}</div>
                    <div class="prac-zh">{{practiceCurrent.word.zh}}</div>
                    <div class="prac-example" v-if="practiceCurrent.word.ex">"{{practiceCurrent.word.ex}}"</div>
                    <div class="prac-hint">{{ui.practiceHint}}<span class="prac-partial">{{practiceCurrent.partial}}</span></div>
                </template>

                <!-- truefalse: show word = zh pairing, judge correct/wrong -->
                <template v-else-if="practiceCurrent.type === 'truefalse'">
                    <div class="prac-type-label">{{ui.practiceTrueFalse}}</div>
                    <div class="prac-tf-pair">
                        <div class="prac-word" style="font-size:1.9rem;">{{practiceCurrent.word.word}}</div>
                        <div class="prac-tf-eq">=</div>
                        <div class="prac-zh">{{practiceCurrent.displayZh}}</div>
                    </div>
                </template>

                <!-- matching: type label only in card; grid rendered below -->
                <template v-else-if="practiceCurrent.type === 'matching'">
                    <div class="prac-type-label">{{ui.practiceMatching}}</div>
                    <div style="font-size:0.82rem;color:var(--muted);">
                        {{matchElim.length}} / {{practiceCurrent.pairs.length}} ✓
                    </div>
                </template>
            </div>

            <!-- Matching grid (outside card, full-width) -->
            <div v-if="practiceCurrent.type === 'matching'" class="prac-match-wrap">
                <div class="prac-match-col">
                    <button v-for="item in practiceCurrent.leftItems" :key="item.key"
                            class="prac-match-item"
                            :class="{
                                sel:   matchSelLeft === item.key,
                                elim:  matchElim.includes(item.key),
                                shake: matchShakeKeys.includes(item.key),
                            }"
                            @click="selectMatchLeft(item.key)">
                        {{item.label}}
                    </button>
                </div>
                <div class="prac-match-col">
                    <button v-for="item in practiceCurrent.rightItems" :key="item.key"
                            class="prac-match-item"
                            :class="{
                                elim:  matchElim.includes(item.key),
                                shake: matchShakeKeys.includes(item.key),
                            }"
                            :style="matchSelLeft && !matchElim.includes(item.key) ? 'border-color:var(--blue);background:#eff6ff' : ''"
                            @click="selectMatchRight(item.key)">
                        {{item.label}}
                    </button>
                </div>
            </div>

            <!-- MC options (shared by mc-word-to-zh, mc-zh-to-word, mc-audio-to-word) -->
            <div v-if="practiceCurrent.type !== 'spelling' && practiceCurrent.type !== 'truefalse' && practiceCurrent.type !== 'matching'"
                 class="prac-options">
                <button v-for="opt in practiceCurrent.options" :key="opt.value"
                        class="prac-opt"
                        :class="{
                            correct: practiceAnswered && opt.value === practiceCurrent.correct,
                            wrong:   practiceAnswered && practiceSelected === opt.value && opt.value !== practiceCurrent.correct,
                        }"
                        :disabled="practiceAnswered"
                        @click="submitPracticeAnswer(opt.value)">
                    <span>{{opt.label}}</span>
                    <span v-if="practiceAnswered && opt.value === practiceCurrent.correct" class="prac-opt-icon" style="color:var(--green)">✓</span>
                    <span v-else-if="practiceAnswered && practiceSelected === opt.value" class="prac-opt-icon" style="color:var(--red)">✗</span>
                </button>
            </div>

            <!-- True/False buttons -->
            <div v-else-if="practiceCurrent.type === 'truefalse'" class="prac-tf-btns">
                <button class="prac-tf-btn prac-tf-true"
                        :class="{
                            correct: practiceAnswered && practiceCurrent.correct === 'true',
                            wrong:   practiceAnswered && practiceSelected === 'true' && practiceCurrent.correct !== 'true',
                        }"
                        :disabled="practiceAnswered"
                        @click="submitPracticeAnswer('true')">
                    <span>{{ui.practiceTrueBtn}}</span>
                    <span v-if="practiceAnswered && practiceCurrent.correct === 'true'" class="prac-opt-icon" style="color:var(--green)">✓</span>
                    <span v-else-if="practiceAnswered && practiceSelected === 'true'" class="prac-opt-icon" style="color:var(--red)">✗</span>
                </button>
                <button class="prac-tf-btn prac-tf-false"
                        :class="{
                            correct: practiceAnswered && practiceCurrent.correct === 'false',
                            wrong:   practiceAnswered && practiceSelected === 'false' && practiceCurrent.correct !== 'false',
                        }"
                        :disabled="practiceAnswered"
                        @click="submitPracticeAnswer('false')">
                    <span>{{ui.practiceFalseBtn}}</span>
                    <span v-if="practiceAnswered && practiceCurrent.correct === 'false'" class="prac-opt-icon" style="color:var(--green)">✓</span>
                    <span v-else-if="practiceAnswered && practiceSelected === 'false'" class="prac-opt-icon" style="color:var(--red)">✗</span>
                </button>
            </div>

            <!-- Spelling input -->
            <div v-else-if="practiceCurrent.type === 'spelling'" class="prac-spell-wrap">
                <input ref="spellInput"
                       v-model="practiceInput"
                       class="prac-spell-input"
                       :class="{correct: practiceResult === 'correct', wrong: practiceResult === 'wrong'}"
                       :placeholder="ui.practiceInputPh"
                       :disabled="practiceAnswered"
                       @keydown.enter.prevent="!practiceAnswered && submitPracticeAnswer(practiceInput)" />
                <button v-if="!practiceAnswered"
                        class="prac-submit-btn"
                        @click="submitPracticeAnswer(practiceInput)">{{ui.practiceSubmit}}</button>
                <div v-if="practiceAnswered && practiceResult === 'wrong'" class="prac-correct-ans">
                    {{ui.practiceCorrectAns}}<strong>{{practiceCurrent.correct}}</strong>
                </div>
            </div>

            </div><!-- /prac-q key -->
            </transition>

        </template>
    </div>

    <!-- Session Done -->
    <div v-else-if="sessionDone" class="done-scr">

        <!-- Header -->
        <div class="done-header">
            <div class="done-emoji">🎉</div>
            <div class="done-title">{{ui.doneTitle}}</div>
            <div class="done-subtitle">
                {{dailyStreak >= 3 ? '🔥 ' + dailyStreak + (LANG==='zh' ? ' 天连续学习，太棒了！' : '-day streak, keep it up!') : ui.doneSubtitle}}
            </div>
        </div>

        <!-- Stats grid -->
        <div class="done-stats">
            <div class="done-stat">
                <div class="done-stat-val">{{todayLearnedCount}}</div>
                <div class="done-stat-label">{{ui.doneTodayLearned}}</div>
            </div>
            <div class="done-stat">
                <div class="done-stat-val">{{sessionCorrect}}</div>
                <div class="done-stat-label">{{ui.doneSessionCorrect}}</div>
            </div>
            <div class="done-stat">
                <div class="done-stat-val">{{masteredCount}}</div>
                <div class="done-stat-label">{{ui.doneMastered}}</div>
            </div>
            <div class="done-stat">
                <div class="done-stat-val">{{dailyStreak}}</div>
                <div class="done-stat-label">{{ui.doneDailyStreak}}</div>
            </div>
            <div class="done-stat">
                <div class="done-stat-val">{{totalReviewed}}</div>
                <div class="done-stat-label">{{ui.doneTotalReviewed}}</div>
            </div>
            <div class="done-stat">
                <div class="done-stat-val">{{points}}</div>
                <div class="done-stat-label">{{ui.donePoints}}</div>
            </div>
        </div>

        <!-- Level + achievements -->
        <div class="done-meta-row">
            <span class="done-level">{{levelInfo.icon}} {{levelInfo.name}} · {{levelInfo.desc}}</span>
            <span v-if="achievements.length > 0" class="done-achievements">
                <span v-for="id in achievements" :key="id">{{achIcon(id)}}</span>
            </span>
        </div>

        <!-- Tomorrow forecast chip -->
        <div class="done-forecast">{{ui.doneTomorrow(tomorrowDueCount)}}</div>

        <!-- Action cards -->
        <div class="done-actions">
            <!-- Primary: Practice -->
            <button class="done-action done-action-primary" @click="startPractice">
                <span class="done-action-icon">✏️</span>
                <div class="done-action-text">
                    <span class="done-action-title">{{ui.practiceBtn}}</span>
                    <span class="done-action-hint">{{ui.donePracticeHint}}</span>
                </div>
                <span class="done-action-arrow">›</span>
            </button>
            <!-- Secondary: Story -->
            <button class="done-action done-action-secondary" @click="openReading">
                <span class="done-action-icon">📖</span>
                <div class="done-action-text">
                    <span class="done-action-title">{{ui.readingBtn}}</span>
                    <span class="done-action-hint">{{ui.doneStoryHint}}</span>
                </div>
                <span class="done-action-arrow">›</span>
            </button>
            <!-- Tertiary: Study more -->
            <button class="done-action done-action-tertiary" @click="loadMore">
                <span class="done-action-icon">📚</span>
                <div class="done-action-text">
                    <span class="done-action-title">{{ui.doneContinue}}</span>
                    <span class="done-action-hint">{{ui.doneContinueHint}}</span>
                </div>
                <span class="done-action-arrow">›</span>
            </button>
        </div>

        <!-- Share pill — lightweight secondary action -->
        <button class="done-share-pill" @click="shareSession">
            <svg class="share-svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg>
            {{ui.shareBtn}}
        </button>

    </div>

    <!-- Main -->
    <main v-else class="card-area">

        <!-- List view -->
        <template v-if="viewMode === 'list'">
            <div class="wl-wrap">
                <div class="wl-section" v-if="listLearnItems.length">
                    <div class="wl-section-title">{{ui.listToLearn}} · {{listLearnItems.length}}</div>
                    <div class="wl-row" :class="{open: expandedWords[w.word]}"
                         v-for="w in listLearnItems" :key="'l-'+w.word"
                         @click="toggleListWord(w.word)">
                        <div class="wl-row-head">
                            <span class="wl-dot" :class="wlDotClass(w.word)"></span>
                            <span class="wl-word">{{w.word}}</span>
                            <span class="wl-zh-short">{{w.zh}}</span>
                            <span class="wl-chevron">›</span>
                        </div>
                        <div class="wl-detail" v-if="expandedWords[w.word]">
                            <span class="wl-ipa" v-if="dictCache[w.word] && dictCache[w.word].ipa">/{{dictCache[w.word].ipa}}/</span>
                            <span class="wl-pos-badge" v-if="w.pos">{{posZh(w.pos)}}</span>
                            <span class="wl-zh-full">{{w.zh}}</span>
                            <span class="wl-example-text" v-if="dictCache[w.word] && dictCache[w.word].example">"{{dictCache[w.word].example}}"</span>
                        </div>
                    </div>
                </div>
                <div class="wl-section" v-if="listReviewItems.length">
                    <div class="wl-section-title">{{ui.listToReview}} · {{listReviewItems.length}}</div>
                    <div class="wl-row" :class="{open: expandedWords[w.word]}"
                         v-for="w in listReviewItems" :key="'r-'+w.word"
                         @click="toggleListWord(w.word)">
                        <div class="wl-row-head">
                            <span class="wl-dot" :class="wlDotClass(w.word)"></span>
                            <span class="wl-word">{{w.word}}</span>
                            <span class="wl-zh-short">{{w.zh}}</span>
                            <span class="wl-chevron">›</span>
                        </div>
                        <div class="wl-detail" v-if="expandedWords[w.word]">
                            <span class="wl-ipa" v-if="dictCache[w.word] && dictCache[w.word].ipa">/{{dictCache[w.word].ipa}}/</span>
                            <span class="wl-pos-badge" v-if="w.pos">{{posZh(w.pos)}}</span>
                            <span class="wl-zh-full">{{w.zh}}</span>
                            <span class="wl-example-text" v-if="dictCache[w.word] && dictCache[w.word].example">"{{dictCache[w.word].example}}"</span>
                        </div>
                    </div>
                </div>
                <div v-if="!listLearnItems.length && !listReviewItems.length"
                     style="text-align:center;color:var(--muted);padding:40px 0;font-size:.9rem;">
                    {{ui.doneTitle}}
                </div>
            </div>
        </template>

        <!-- Card view -->
        <template v-else>
        <!-- Progress -->
        <div class="prog-row">
            <div class="prog-track">
                <div class="prog-fill" :style="{width: sessionPct + '%'}"></div>
            </div>
            <div class="prog-text">{{queue.length}} {{ui.remaining}}</div>
        </div>

        <!-- Card -->
        <div class="card-wrap" :class="{shaking, bouncing}">
            <div class="card" :class="{flipped}"
                 @click="onCardClick"
                 tabindex="0"
                 ref="card">

                <!-- Front -->
                <div class="face front">
                    <!-- Stage badge: shows 学习中/熟悉/已掌握 etc. so user knows what to expect -->
                    <div class="front-stage" :class="'fs-' + curStage"
                         v-if="curStage && curStage !== 'new' && curStage !== 'mastered'">
                        {{stageLabel[curStage]}}
                    </div>
                    <div class="pos-tag" v-if="curDict && curDict.pos">
                        {{posZh(curDict.pos)}}
                    </div>
                    <div class="front-word">{{cur.word}}</div>
                    <div class="front-ipa"
                         :class="{fetching: cur.word && !(cur.word in dictCache)}">
                        {{curDict && curDict.ipa ? curDict.ipa : (cur.word && !(cur.word in dictCache) ? '···' : '')}}
                    </div>
                    <button class="audio-btn" :class="{playing: audioPlaying}"
                            @click.stop="playAudio(cur.word)">
                        <span>🔊</span> <span>{{audioPlaying ? ui.audioPlaying : ui.audioPlay}}</span>
                    </button>
                    <div class="front-hint">{{ui.flipHint}}</div>
                </div>

                <!-- Back -->
                <div class="face back">
                    <div class="stage-tag" :class="'st-' + curStage">
                        {{stageLabel[curStage]}}
                    </div>
                    <!-- ① word + IPA on one line -->
                    <div class="back-header">
                        <span class="back-word">{{cur.word}}</span>
                        <span class="back-ipa" v-if="curDict && curDict.ipa">{{curDict.ipa}}</span>
                    </div>
                    <!-- ② full form (abbreviations) -->
                    <div class="back-fullform" v-if="curZhParts.full">{{curZhParts.full}}</div>
                    <!-- ③ Chinese meaning — hero -->
                    <div class="back-zh">{{curZhParts.zh}}</div>
                    <!-- ④ pos + English definition -->
                    <div class="back-def-row" v-if="(curDict && curDict.pos) || (curDict && curDict.definition)">
                        <span class="back-pos" v-if="curDict && curDict.pos">{{posZh(curDict.pos)}}</span>
                        <span class="back-def" v-if="curDict && curDict.definition">{{curDict.definition}}</span>
                    </div>
                    <!-- ⑤ example sentences with separator -->
                    <div class="back-examples" v-if="curExample || curExample2">
                        <div class="back-example" v-if="curExample">"{{curExample.text}}"</div>
                        <div class="back-example2" v-if="curExample2">"{{curExample2}}"</div>
                    </div>
                    <div class="back-note" v-if="curNote">{{curNote}}</div>
                </div>
            </div>
        </div>

        <!-- Buttons (after flip) -->
        <div class="controls-wrap">
            <div class="controls" :class="{visible: flipped && !slideshowMode}">
                <button class="cb cb-again" @click="answer('again')" :disabled="!flipped">
                    <span class="cb-label">{{ui.btnAgain}}</span>
                    <span class="cb-interval">{{iv('again')}}</span>
                </button>
                <button class="cb cb-hard" @click="answer('hard')" :disabled="!flipped">
                    <span class="cb-label">{{ui.btnHard}}</span>
                    <span class="cb-interval">{{iv('hard')}}</span>
                </button>
                <button class="cb cb-good" @click="answer('good')" :disabled="!flipped">
                    <span class="cb-label">{{ui.btnGood}}</span>
                    <span class="cb-interval">{{iv('good')}}</span>
                </button>
                <button class="cb cb-easy" @click="answer('easy')" :disabled="!flipped">
                    <span class="cb-label">{{ui.btnEasy}}</span>
                    <span class="cb-interval">{{iv('easy')}}</span>
                </button>
            </div>
            <div class="key-hint" :class="{visible: !flipped && !slideshowMode}" v-html="ui.keyHint"></div>
        </div>

        </template><!-- end card view -->

        <!-- ── Mode bar：视图切换 + 自动播放（始终可见）──── -->
        <div class="mode-bar">
            <button class="mode-btn" :class="{active: viewMode==='list'}"
                    @click="toggleView">
                {{viewMode === 'card' ? '☰ ' + ui.viewList : '⊟ ' + ui.viewCard}}
            </button>
            <button class="mode-btn mode-btn-play" :class="{active: slideshowMode}"
                    @click="toggleSlideshow"
                    v-if="viewMode === 'card'">
                {{slideshowMode ? ui.slideshowStop : ui.slideshowStart}}
            </button>
        </div>
    </main>

    <!-- Footer -->
    <div v-if="!loading && !sessionDone && !practiceMode" class="ft">
        <div class="ft-row">
            <span>{{ui.ftPoints}} <strong>{{points}}</strong></span>
            <span>{{ui.ftStreak}} <strong>{{streak}}</strong></span>
            <span>{{ui.ftMastered}} <strong>{{masteredCount}}</strong> / {{allWords.length}}</span>
            <span>{{ui.ftTotalReviewed}} <strong>{{totalReviewed}}</strong></span>
        </div>
        <div class="xp-row">
            <span class="xp-label">{{levelInfo.icon}} {{levelInfo.name}}</span>
            <div class="xp-track">
                <div class="xp-fill" :style="{width: levelProgress + '%'}"></div>
            </div>
            <span class="xp-next" v-if="nextLevelInfo">{{nextLevelInfo.icon}} {{nextLevelInfo.name}}</span>
            <span class="xp-next" v-else>{{ui.ftMaxLevel}}</span>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast-anchor">
        <transition name="toast">
            <div v-if="toast" class="toast" :class="'t-' + toast.type">{{toast.msg}}</div>
        </transition>
    </div>

    <!-- Undo last answer button (visible for 4s after each SRS answer) -->
    <transition name="toast">
        <button v-if="showUndo && !practiceMode" class="undo-btn" @click="undoAnswer">{{ui.undoBtn}}</button>
    </transition>

    <!-- ── Word list modal (bottom sheet) ──────────────────────────── -->
    <transition name="toast">
        <div v-if="wordListModal" class="wl-overlay" @click.self="closeWordList">
            <div class="wl-sheet">
                <div class="wl-header">
                    <div class="wl-title">{{wordListModal.title}}</div>
                    <div class="wl-count">{{wordListModal.words.length}}</div>
                    <button class="wl-close" @click="closeWordList">✕</button>
                </div>
                <div class="wl-list">
                    <div v-if="wordListModal.words.length === 0" class="wl-empty">{{ui.wlEmpty}}</div>
                    <div v-for="w in wordListModal.words" :key="w.word" class="wl-item">
                        <span class="wl-en">{{w.word}}</span>
                        <span class="wl-pos" v-if="w.pos">{{w.pos}}</span>
                        <span class="wl-zh">{{w.zh}}</span>
                        <span class="wl-stage-badge"
                              :class="'wl-badge-' + (state[w.word] ? state[w.word].stage : 'new')">
                            {{ui.stages[state[w.word] ? state[w.word].stage : 'new']}}
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </transition>

    <!-- ── Reading overlay ─────────────────────────────────────────── -->
    <div v-if="readingOpen" class="reading-overlay">
        <div class="reading-hd">
            <span class="reading-hd-title">📖 {{ui.readingTitle}}</span>
            <div style="display:flex;gap:6px;align-items:center">
                <button v-if="geminiKey" class="reading-hist-btn"
                        :class="{active: readingHistoryOpen}"
                        @click="readingHistoryOpen = !readingHistoryOpen">
                    📋 {{ui.readingHistory}}
                </button>
                <button class="reading-close" @click="closeReading">✕</button>
            </div>
        </div>
        <div class="reading-body">
            <!-- Key input (no key saved yet) -->
            <div v-if="!geminiKey" class="reading-key-area">
                <div class="reading-key-info">🔑 {{ui.readingKeyInfo}}</div>
                <div class="reading-key-steps">
                    <p class="reading-key-step">
                        <span class="reading-key-num">1</span>{{ui.readingKeyStep1}}
                    </p>
                    <a class="reading-key-cta" href="https://aistudio.google.com/app/apikey" target="_blank">{{ui.readingKeyLink}}</a>
                    <p class="reading-key-step">
                        <span class="reading-key-num">2</span>{{ui.readingKeyStep2}}
                    </p>
                </div>
                <div class="reading-key-row">
                    <input class="reading-key-input" v-model="geminiKeyInput"
                           :placeholder="ui.readingKeyPh"
                           @keyup.enter="saveGeminiKey" />
                    <button class="reading-key-paste" @click="pasteApiKey" :title="ui.readingPaste">📋</button>
                    <button class="reading-key-save" @click="saveGeminiKey">{{ui.readingKeySave}}</button>
                </div>
            </div>

            <!-- History list -->
            <template v-else-if="readingHistoryOpen">
                <div v-if="readingHistory.length === 0" class="reading-hist-empty">
                    {{ui.readingHistoryEmpty}}
                </div>
                <div v-for="entry in readingHistory" :key="entry.id"
                     class="reading-hist-item" @click="openHistoryItem(entry)">
                    <div class="reading-hist-meta">
                        <span class="reading-hist-date">{{entry.date}}</span>
                        <span class="reading-hist-deck">{{entry.deckId}}</span>
                        <span class="reading-hist-wcount">{{entry.words.length}} {{LANG==='zh'?'词':'words'}}</span>
                    </div>
                    <div class="reading-hist-preview">{{entry.text.slice(0,100)}}…</div>
                </div>
            </template>

            <!-- Loading -->
            <div v-else-if="readingLoading" class="reading-loading">
                <div class="reading-spinner"></div>
                <span class="reading-loading-main">{{ui.readingLoading}}</span>
                <span class="reading-loading-sub">✨ {{readingWordObjs.length > 0 ? readingWordObjs.length + (LANG === 'zh' ? ' 个词汇' : ' words') : ''}}</span>
            </div>

            <!-- Error -->
            <div v-else-if="readingError" class="reading-error">
                <div class="reading-error-icon">⚠️</div>
                <div class="reading-error-msg">{{readingError}}</div>
                <button class="reading-regen" @click="generateReading">🔄 {{ui.readingRegen}}</button>
            </div>

            <!-- Article -->
            <template v-else-if="readingArticle">
                <div class="reading-article" v-html="highlightedArticle" @click="onVocabHlClick"></div>
                <div class="reading-word-list">
                    <span style="font-weight:600;color:var(--text)">{{ui.readingWordList}}</span>
                    <span v-for="(w, i) in readingWordObjs" :key="w.word">
                        <strong style="color:var(--blue)">{{w.word}}</strong><span style="color:var(--muted)"> {{w.zh}}</span><span v-if="i < readingWordObjs.length - 1"> · </span>
                    </span>
                </div>
                <button class="reading-regen" @click="generateReading">🔄 {{ui.readingRegen}}</button>
            </template>
        </div>
    </div>

    <!-- ── Onboarding overlay (new user) ───────────────────────────── -->
    <div v-if="showOnboarding" class="ob-overlay">
        <div class="ob-panel">
        <!-- Header -->
        <div class="ob-hd">
            <span></span>
            <button class="ob-skip" @click="dismissOnboarding">{{ui.obSkip}} ✕</button>
        </div>

        <!-- Scrollable body -->
        <div class="ob-body">

            <!-- Hero -->
            <div class="ob-hero">
                <img class="ob-logo" src="icons/apple-touch-icon.png" alt="VocabLoop">
                <div class="ob-brand">VocabLoop</div>
                <div class="ob-tagline">{{ui.obTagline}}</div>
            </div>

            <!-- SRS -->
            <div class="ob-section">
                <div class="ob-section-title">{{ui.obSrsTitle}}</div>
                <div class="ob-section-body">{{ui.obSrsDesc}}</div>
            </div>

            <!-- Decks -->
            <div class="ob-section">
                <div class="ob-section-title">{{ui.obDecksTitle}}</div>
                <div class="ob-decks">
                    <div class="ob-deck">
                        <span class="ob-deck-icon">📚</span>
                        <div>
                            <div class="ob-deck-name">{{ui.deckPET}}</div>
                            <div class="ob-deck-desc">{{ui.obDeckPetDesc}}</div>
                        </div>
                    </div>
                    <div class="ob-deck">
                        <span class="ob-deck-icon">💬</span>
                        <div>
                            <div class="ob-deck-name">{{ui.deckDaily}}</div>
                            <div class="ob-deck-desc">{{ui.obDeckDailyDesc}}</div>
                        </div>
                    </div>
                    <div class="ob-deck">
                        <span class="ob-deck-icon">🎓</span>
                        <div>
                            <div class="ob-deck-name">{{ui.deckIELTS}}</div>
                            <div class="ob-deck-desc">{{ui.obDeckIeltsDesc}}</div>
                        </div>
                    </div>
                    <div class="ob-deck">
                        <span class="ob-deck-icon">₿</span>
                        <div>
                            <div class="ob-deck-name">{{ui.deckCrypto}}</div>
                            <div class="ob-deck-desc">{{ui.obDeckCryptoDesc}}</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- How to use -->
            <div class="ob-section">
                <div class="ob-section-title">{{ui.obHowTitle}}</div>
                <div class="ob-steps">
                    <div class="ob-step">
                        <span class="ob-step-num">1</span>
                        <span>{{ui.obStep1}}</span>
                    </div>
                    <div class="ob-step">
                        <span class="ob-step-num">2</span>
                        <span>{{ui.obStep2}}</span>
                    </div>
                    <div class="ob-step">
                        <span class="ob-step-num">3</span>
                        <span>{{ui.obStep3}}</span>
                    </div>
                </div>
            </div>

            <div style="height:80px"></div>
        </div>

        <!-- Fixed CTA footer -->
        <div class="ob-footer">
            <button class="ob-cta" @click="dismissOnboarding">{{ui.obCta}}</button>
        </div>
        </div><!-- /ob-panel -->
    </div>

    <!-- ── Daily Welcome (returning users) ───────────────────────────────── -->
    <div v-if="showDailyWelcome" class="dw-overlay" @click.self="dismissDailyWelcome">
        <div class="dw-card">
            <button class="dw-close" @click="dismissDailyWelcome">✕</button>

            <!-- Streak hero -->
            <div class="dw-streak">
                <div class="dw-streak-emoji">{{ui.dwStreakEmoji(dailyWelcomeDay)}}</div>
                <div class="dw-streak-num">{{ui.dwStreakLabel(dailyWelcomeDay)}}</div>
                <div class="dw-streak-sub">{{ui.dwSubtitle(dailyWelcomeDay)}}</div>
            </div>

            <div class="dw-divider"></div>

            <!-- Quote -->
            <div v-if="dailyWelcomeQuote" class="dw-quote-wrap">
                <div class="dw-quote-text">"{{dailyWelcomeQuote.text}}"</div>
                <div class="dw-quote-author">— {{dailyWelcomeQuote.author}}</div>
            </div>

            <button class="dw-cta" @click="dismissDailyWelcome">{{ui.dwCta}}</button>
        </div>
    </div>

</div>

<!-- ── Force-refresh zone ──────────────────────────────────────────────── -->
<div id="upd-zone">
    <button id="upd-btn">
        <span class="upd-ring">↻</span>
        <span class="upd-txt"></span>
    </button>
    <p class="brand-tagline">VocabLoop · Your memory, on a perfect loop.</p>
</div>

<!-- ── Android PWA install banner ─────────────────────────────────────── -->
<div id="pwa-android">
    <img class="pwa-icon" src="icons/apple-touch-icon.png" alt="VocabLoop">
    <div class="pwa-text">
        <strong>VocabLoop</strong>
        <span id="pwa-android-desc"></span>
    </div>
    <button id="pwa-install-btn"></button>
    <button id="pwa-dismiss-android" aria-label="dismiss">✕</button>
</div>

<!-- ── iOS "Add to Home Screen" guide ────────────────────────────────── -->
<div id="pwa-ios">
    <div id="pwa-ios-card">
        <div class="pwa-header">
            <img src="icons/apple-touch-icon.png" alt="VocabLoop icon">
            <div class="pwa-header-text">
                <h3 id="pwa-ios-title"></h3>
                <p id="pwa-ios-desc"></p>
            </div>
        </div>
        <div class="pwa-steps">
            <div class="pwa-step">
                <div class="step-num">1</div>
                <div class="step-text" id="pwa-step1"></div>
                <div class="step-icon">⬆️</div>
            </div>
            <div class="pwa-step">
                <div class="step-num">2</div>
                <div class="step-text" id="pwa-step2"></div>
                <div class="step-icon">📲</div>
            </div>
            <div class="pwa-step">
                <div class="step-num">3</div>
                <div class="step-text" id="pwa-step3"></div>
                <div class="step-icon">✅</div>
            </div>
        </div>
        <button id="pwa-dismiss-ios"></button>
    </div>
</div>

<script>
// ── Internationalisation ────────────────────────────────────────────────────
const LANG = /^zh/i.test(navigator.language) ? 'zh' : 'en';
// ── 30 quotes: perseverance · success · language learning ─────────────────
const DAILY_QUOTES = [
  { text: "The secret of getting ahead is getting started.", author: "Mark Twain" },
  { text: "It does not matter how slowly you go as long as you do not stop.", author: "Confucius" },
  { text: "Success is the sum of small efforts, repeated day in and day out.", author: "Robert Collier" },
  { text: "The limits of my language mean the limits of my world.", author: "Ludwig Wittgenstein" },
  { text: "A different language is a different vision of life.", author: "Federico Fellini" },
  { text: "To have another language is to possess a second soul.", author: "Charlemagne" },
  { text: "Fall seven times, stand up eight.", author: "Japanese Proverb" },
  { text: "The man who moves a mountain begins by carrying away small stones.", author: "Confucius" },
  { text: "Don't watch the clock; do what it does. Keep going.", author: "Sam Levenson" },
  { text: "You don't have to be great to start, but you have to start to be great.", author: "Zig Ziglar" },
  { text: "The beautiful thing about learning is that no one can take it away from you.", author: "B.B. King" },
  { text: "One language sets you in a corridor for life. Two languages open every door along the way.", author: "Frank Smith" },
  { text: "Language is the road map of a culture.", author: "Rita Mae Brown" },
  { text: "Perseverance is failing 19 times and succeeding the 20th.", author: "Julie Andrews" },
  { text: "Energy and persistence conquer all things.", author: "Benjamin Franklin" },
  { text: "It always seems impossible until it's done.", author: "Nelson Mandela" },
  { text: "With languages, you are at home anywhere.", author: "Edmund de Waal" },
  { text: "Small daily improvements over time lead to stunning results.", author: "Robin Sharma" },
  { text: "Every accomplishment starts with the decision to try.", author: "John F. Kennedy" },
  { text: "Continuous effort — not strength or intelligence — is the key to unlocking our potential.", author: "Winston Churchill" },
  { text: "Learning is not attained by chance; it must be sought for with ardor and diligence.", author: "Abigail Adams" },
  { text: "Knowledge of languages is the doorway to wisdom.", author: "Roger Bacon" },
  { text: "He who knows no foreign languages knows nothing of his own.", author: "Goethe" },
  { text: "Do not be embarrassed by your failures, learn from them and start again.", author: "Richard Branson" },
  { text: "The more languages you know, the more you are human.", author: "Tomáš Masaryk" },
  { text: "Excellence is not a destination but a continuous journey that never ends.", author: "Brian Tracy" },
  { text: "Your future is created by what you do today, not tomorrow.", author: "Robert Kiyosaki" },
  { text: "If you talk to a man in his own language, that goes to his heart.", author: "Nelson Mandela" },
  { text: "A man who dares to waste one hour of time has not discovered the value of life.", author: "Charles Darwin" },
  { text: "Every day is a new beginning. Take a deep breath and start again.", author: "Anonymous" },
];

const STRINGS = {
  zh: {
    deckPET: 'PET 词汇', deckCrypto: 'Crypto 词汇', deckDaily: '日常口语', deckIELTS: '雅思词汇',
    autoPlayOn:  '自动朗读：开（点击关闭）', autoPlayOff: '自动朗读：关（点击开启）',
    listToLearn: '今日新学', listToReview: '今日复习',
    viewList: '切换到列表', viewCard: '切换到卡片',
    exportBtn: '导出', importBtn: '导入', resetBtn: '重置', dayUnit: '天',
    importConfirm: '将从文件中导入学习记录。\n已有的单词将智能合并（保留复习更近的版本），不会丢失现有进度。\n\n确定导入吗？',
    importOk: (n) => `导入成功！已合并 ${n} 个词库的数据`,
    importFail: '导入失败：文件格式不正确',
    importEmpty: '文件中没有找到学习记录',
    loading: '正在加载词汇...',
    doneTitle: '今日任务完成！',
    doneTodayLearned: '今日新学', doneSessionCorrect: '本次答对',
    doneMastered: '已掌握', doneDailyStreak: '📅 连续天数',
    doneTotalReviewed: '累计答题', donePoints: '积分',
    doneContinue: '继续学习更多单词', achLabel: '成就',
    doneSubtitle:      '今天的积累，是明天流利的基础 ✨',
    donePracticeHint:  '做题检验，真正掌握今日词汇',
    doneStoryHint:     '在真实语境的故事中巩固记忆',
    doneContinueHint:  '继续学习，认识更多新单词',
    doneTomorrow:      (n) => n > 0 ? `📅 明天有 ${n} 个词等你复习` : '今天的词汇已安排到最优复习时间',
    donePracticeKey:   '键盘 1-4 快速选择',
    audioPlaying: '播放中…', audioPlay: '发音',
    flipHint: '点击翻转 · 按空格键',
    btnAgain: '忘了', btnHard: '模糊', btnGood: '记住了', btnEasy: '很熟',
    keyHint: '空格翻转 &nbsp;·&nbsp; 翻转后：← 忘了 &nbsp; ↓ 模糊 &nbsp; → 记住 &nbsp; ↑ 很熟',
    ftPoints: '积分', ftStreak: '连击', ftMastered: '掌握',
    ftTotalReviewed: '总复习', ftMaxLevel: '👑 满级', remaining: '剩余',
    now: '现在', min: ' 分钟', day: ' 天',
    graduated:  '🎓 初步掌握！',
    mastered:   (n) => `🏆 已掌握 ${n} 个单词！`,
    reviewToday: (n) => `🔄 再刷一遍今日 ${n} 个词！`,
    noMoreWords:  '所有词汇都学完了！\n请明天继续复习到期的单词。',
    loadError:    (msg, file) => `加载词汇失败：${msg}\n请确保文件 ${file} 存在。`,
    confirmReset: (name) => `确定重置【${name}】的学习进度吗？\n词典缓存会保留。`,
    achievementUnlocked: (icon, name) => `${icon} 成就解锁：${name}`,
    againMsgs: ['没关系，再来！💪', '继续加油！🔄', '复习一次！📖', '不怕，慢慢来！🌱'],
    goodMsgs:  ['✓ 很好！', '👍 记住了！', '💪 不错！', '✨ 棒！', '🎯 准确！', '👏 继续！', '💡 清晰！', '🌟 很棒！'],
    easyMsgs:  ['太棒了！🌟', '完美！⭐', '出色！🚀', '厉害！💎', '超强！⚡', '满分！🎯'],
    streakToasts: {
      3:  { msg: '👍 连击 3！',            type: 'good' },
      5:  { msg: '🔥 连击 5！',            type: 'bonus' },
      7:  { msg: '⚡ 连击 7！燃起来！',    type: 'bonus' },
      10: { msg: '🔥 连击 10！超厉害！',   type: 'bonus' },
      15: { msg: '💎 连击 15！无敌！',     type: 'bonus' },
      20: { msg: '👑 连击 20！传奇！',     type: 'bonus' },
      30: { msg: '🌟 连击 30！封神！',     type: 'bonus' },
      50: { msg: '🚀 连击 50！无人能及！', type: 'bonus' },
    },
    stages: { new: '新词', learning: '学习中', young: '熟悉', mature: '已掌握', relearn: '重学', mastered: '完全掌握' },
    levels: [
      { min:    0, icon: '🌱', name: '初学者', desc: '继续加油！' },
      { min:   50, icon: '📘', name: '入门者', desc: '进步神速！' },
      { min:  150, icon: '⭐', name: '进阶者', desc: '词汇量不错！' },
      { min:  350, icon: '🎯', name: '熟练者', desc: '相当厉害！' },
      { min:  600, icon: '🏆', name: '精通者', desc: '词汇达人！' },
      { min: 1000, icon: '👑', name: '宗师',   desc: '登峰造极！' },
    ],
    achievements: [
      { id: 'first_answer',  icon: '🎯', name: '第一步',    desc: '完成第一次答题' },
      { id: 'streak_5',      icon: '🔥', name: '连击 5',    desc: '单次连击达到 5' },
      { id: 'streak_20',     icon: '⚡', name: '连击 20',   desc: '单次连击达到 20' },
      { id: 'daily_3',       icon: '📅', name: '三日连续',  desc: '连续学习 3 天' },
      { id: 'daily_7',       icon: '🗓️', name: '坚持一周',  desc: '连续学习 7 天' },
      { id: 'daily_30',      icon: '🏅', name: '月度达人',  desc: '连续学习 30 天' },
      { id: 'master_1',      icon: '⭐', name: '初掌',      desc: '掌握第 1 个单词' },
      { id: 'master_10',     icon: '🌟', name: '十词达人',  desc: '掌握 10 个单词' },
      { id: 'master_100',    icon: '💯', name: '百词大师',  desc: '掌握 100 个单词' },
      { id: 'reviewed_100',  icon: '📖', name: '百次答题',  desc: '累计答题 100 次' },
      { id: 'reviewed_500',  icon: '📚', name: '五百勤练',  desc: '累计答题 500 次' },
    ],
    // ── Practice Mode ──────────────────────────────────────────────────────
    practiceBtn:           '练习',
    practiceNoWords:       '还没有学过任何单词，先去学习一些吧',
    practiceMCWordToZh:    '选出正确的中文意思',
    practiceMCZhToWord:    '选出对应的英文单词',
    practiceMCAudioToWord: '听发音，选出对应单词',
    practiceSpelling:      '根据提示补全拼写',
    practiceTrueFalse:     '判断搭配是否正确',
    practiceHint:          '提示：',
    practiceInputPh:       '输入完整单词…',
    practiceSubmit:        '确认',
    practiceNext:          '下一题 →',
    practiceTrueBtn:       '✓ 正确',
    practiceFalseBtn:      '✗ 错误',
    practiceMatching:      '连一连 · 选中左边再点右边配对',
    practiceCorrect:       '✓ 正确！',
    practiceWrong:         '✗ 错误',
    practiceCorrectAns:    '正确答案：',
    practiceDoneTitle:     '练习完成！',
    practiceDoneScore:     (c, t) => `答对 ${c} / ${t} 题`,
    practiceDoneBack:      '返回',
    practiceWrongTitle:    '需要加强的词汇',
    shareBtn:              '分享给朋友',
    shareHint:             '把你的学习成果分享给朋友',
    shareCopied:           '已复制，去分享吧！',
    shareCopyFallback:     '复制以下内容分享：',
    obTagline:       '间隔重复英语词汇 · 科学记忆',
    obSrsTitle:      '🧠 科学记忆原理',
    obSrsDesc:       '基于间隔重复算法（SRS）——刚学的词频繁出现，记熟的词逐渐拉长间隔。系统在最该复习的时刻推送单词，用最少时间记最多词。',
    obDecksTitle:    '📚 四大词库',
    obDeckPetDesc:   '剑桥 PET 考试核心词汇，夯实英语基础',
    obDeckDailyDesc: '职场口语 · 网络缩写 · 日常高频短语',
    obDeckIeltsDesc: '雅思考试学术词汇 · B2–C1 高频核心词',
    obDeckCryptoDesc:'区块链 · DeFi · Web3 专业术语',
    obHowTitle:      '🃏 如何使用',
    obStep1:         '看到单词，回忆含义，点击卡片翻开',
    obStep2:         '按记忆程度评分：忘了 / 模糊 / 记住了 / 很熟',
    obStep3:         '每天坚持，系统安排最优复习时间',
    obCta:           '开始学习 →',
    obSkip:          '跳过',
    dwStreakEmoji:   n => n >= 30 ? '🏆' : n >= 14 ? '🔥' : n >= 7 ? '✨' : '🌱',
    dwStreakLabel:   n => `第 ${n} 天`,
    dwSubtitle:      n => n >= 30 ? `连续学习 ${n} 天，你是真正的学习达人！` : n >= 14 ? `已坚持 ${n} 天，状态超棒，继续冲！` : n >= 7 ? `已坚持 ${n} 天，习惯正在养成！` : `已坚持 ${n} 天，继续保持！`,
    dwCta:           '继续学习 →',
    slideshowStart:  '▷ 自动播放',
    slideshowStop:   '⏸ 停止',
    practicePlayAgain:     '再听一遍',
    practiceExitBtn:       '退出练习',
    undoBtn:               '↩ 撤销',
    wlNew:     '🆕 未学单词',
    wlLearn:   '📖 学习中（学习 + 早期复习）',
    wlReview:  '🔁 深度记忆（间隔 ≥ 21 天）',
    wlMastered:'🏆 已完全掌握',
    wlEmpty:   '暂无单词',
    wlClose:   '关闭',
    readingBtn:      '延伸阅读',
    readingTitle:    '今日词汇文章',
    readingClose:    '关闭',
    readingKeyInfo:  '需要免费的 Gemini API Key 来生成文章',
    readingKeyLink:  '点此免费获取 →',
    readingKeyPh:    '粘贴你的 Gemini API Key',
    readingKeySave:  '保存并生成',
    readingLoading:  'AI 正在写作中…',
    readingError:    '生成失败，请重试',
    readingErr429:   '请求太频繁，请稍等1分钟后再试 🕐',
    readingErrKey:   'API Key 无效或权限不足',
    readingErrNet:   '网络连接失败，请检查网络后重试',
    readingErrTime:  '请求超时，请重试',
    readingRegen:    '重新生成',
    readingWordList:     '本篇涵盖词汇：',
    readingHistory:      '历史',
    readingHistoryEmpty: '暂无历史文章',
    readingPaste:        '粘贴',
    readingKeyStep1:     '前往 Google AI Studio 获取免费 Key',
    readingKeyStep2:     '复制 Key，粘贴到下方输入框',
    pwaAndroidDesc: '添加到主屏幕，随时随地刷词', pwaAndroidInstall: '安装', pwaAndroidDismiss: '关闭',
    pwaIOSTitle: '添加 VocabLoop 到主屏幕', pwaIOSDesc: '像 App 一样随时打开，无需浏览器',
    pwaIOSStep1: '点击底部工具栏的 <em>分享</em> 按钮',
    pwaIOSStep2: '向下滑动，选择 <em>「添加到主屏幕」</em>',
    pwaIOSStep3: '点击右上角 <em>「添加」</em>，大功告成！',
    pwaIOSDismiss: '我知道了',
    syncBtn: '同步', syncSyncing: '同步中…', syncDone: '已同步', syncFail: '同步失败',
    syncPull: '正在拉取云端数据…', syncPush: '正在上传数据…',
    syncMerged: '已合并云端与本地数据', syncNoAccount: '请先登录以同步学习记录',
    syncTokenExpired: '登录已过期，请重新登录',
    syncUpToDate: '数据已是最新', syncLastSync: (t) => `上次同步：${t}`,
  },
  en: {
    deckPET: 'PET Vocab', deckCrypto: 'Crypto', deckDaily: 'Daily English', deckIELTS: 'IELTS',
    autoPlayOn:  'Auto-read: ON (tap to disable)', autoPlayOff: 'Auto-read: OFF (tap to enable)',
    listToLearn: 'To Learn', listToReview: 'To Review',
    viewList: 'Switch to list', viewCard: 'Switch to cards',
    exportBtn: 'Export', importBtn: 'Import', resetBtn: 'Reset', dayUnit: 'd',
    importConfirm: 'Import learning records from file.\nExisting words will be smart-merged (keeping the more recently reviewed version). No data will be lost.\n\nProceed?',
    importOk: (n) => `Imported! Merged data from ${n} deck${n === 1 ? '' : 's'}`,
    importFail: 'Import failed: invalid file format',
    importEmpty: 'No learning records found in file',
    loading: 'Loading vocabulary…',
    doneTitle: 'Session complete!',
    doneTodayLearned: 'New today', doneSessionCorrect: 'Correct',
    doneMastered: 'Mastered', doneDailyStreak: '📅 Day streak',
    doneTotalReviewed: 'Reviews', donePoints: 'Points',
    doneContinue: 'Study more words', achLabel: 'Badges',
    doneSubtitle:      'Small daily steps create big results ✨',
    donePracticeHint:  'Test yourself and truly lock in today\'s words',
    doneStoryHint:     'See your words come alive in a real story',
    doneContinueHint:  'Keep going and learn even more new words',
    doneTomorrow:      (n) => n > 0 ? `📅 ${n} cards due tomorrow — come back!` : 'All cards scheduled at optimal intervals',
    donePracticeKey:   'Keys 1–4 to pick answers fast',
    audioPlaying: 'Playing…', audioPlay: 'Pronounce',
    flipHint: 'Tap to flip · Space',
    btnAgain: 'Again', btnHard: 'Hard', btnGood: 'Good', btnEasy: 'Easy',
    keyHint: 'Space: flip &nbsp;·&nbsp; After flip: ← Again &nbsp; ↓ Hard &nbsp; → Good &nbsp; ↑ Easy',
    ftPoints: 'Points', ftStreak: 'Streak', ftMastered: 'Mastered',
    ftTotalReviewed: 'Reviews', ftMaxLevel: '👑 Max level', remaining: 'left',
    now: 'now', min: ' min', day: 'd',
    graduated:  '🎓 Graduated!',
    mastered:   (n) => `🏆 Mastered ${n} word${n === 1 ? '' : 's'}!`,
    reviewToday: (n) => `🔄 Re-reviewing today's ${n} words!`,
    noMoreWords:  "All words done!\nCome back tomorrow for due cards.",
    loadError:    (msg, file) => `Failed to load: ${msg}\nMake sure ${file} exists.`,
    confirmReset: (name) => `Reset progress for "${name}"?\n(Dictionary cache is kept.)`,
    achievementUnlocked: (icon, name) => `${icon} Achievement: ${name}`,
    againMsgs: ["No worries, try again! 💪", "Keep going! 🔄", "Review time! 📖", "Slow and steady! 🌱"],
    goodMsgs:  ['✓ Got it!', '👍 Nailed it!', '💪 Nice!', '✨ Great!', '🎯 Spot on!', '👏 Keep it up!', '💡 Clear!', '🌟 Excellent!'],
    easyMsgs:  ['Awesome! 🌟', 'Perfect! ⭐', 'Outstanding! 🚀', 'Superb! 💎', 'Blazing! ⚡', 'Flawless! 🎯'],
    streakToasts: {
      3:  { msg: '👍 3-streak!',          type: 'good' },
      5:  { msg: '🔥 5-streak!',          type: 'bonus' },
      7:  { msg: '⚡ 7-streak! On fire!', type: 'bonus' },
      10: { msg: '🔥 10-streak! Amazing!',type: 'bonus' },
      15: { msg: '💎 15-streak! Insane!', type: 'bonus' },
      20: { msg: '👑 20-streak! Legend!', type: 'bonus' },
      30: { msg: '🌟 30-streak! Godlike!',type: 'bonus' },
      50: { msg: '🚀 50-streak! Unreal!', type: 'bonus' },
    },
    stages: { new: 'New', learning: 'Learning', young: 'Young', mature: 'Seasoned', relearn: 'Relearn', mastered: 'Mastered ✓' },
    levels: [
      { min:    0, icon: '🌱', name: 'Beginner',   desc: 'Keep it up!' },
      { min:   50, icon: '📘', name: 'Novice',     desc: 'Great progress!' },
      { min:  150, icon: '⭐', name: 'Learner',    desc: 'Nice vocabulary!' },
      { min:  350, icon: '🎯', name: 'Proficient', desc: 'Impressive!' },
      { min:  600, icon: '🏆', name: 'Advanced',   desc: 'Vocabulary pro!' },
      { min: 1000, icon: '👑', name: 'Expert',     desc: 'The pinnacle!' },
    ],
    achievements: [
      { id: 'first_answer',  icon: '🎯', name: 'First Step',    desc: 'Complete your first review' },
      { id: 'streak_5',      icon: '🔥', name: 'Streak ×5',     desc: 'Hit a 5-card streak' },
      { id: 'streak_20',     icon: '⚡', name: 'Streak ×20',    desc: 'Hit a 20-card streak' },
      { id: 'daily_3',       icon: '📅', name: '3-Day Run',     desc: 'Study 3 days in a row' },
      { id: 'daily_7',       icon: '🗓️', name: 'Full Week',     desc: 'Study 7 days in a row' },
      { id: 'daily_30',      icon: '🏅', name: 'Monthly Pro',   desc: 'Study 30 days in a row' },
      { id: 'master_1',      icon: '⭐', name: 'First Word',    desc: 'Master your first word' },
      { id: 'master_10',     icon: '🌟', name: 'Ten Words',     desc: 'Master 10 words' },
      { id: 'master_100',    icon: '💯', name: 'Century',       desc: 'Master 100 words' },
      { id: 'reviewed_100',  icon: '📖', name: '100 Reviews',   desc: 'Complete 100 reviews' },
      { id: 'reviewed_500',  icon: '📚', name: '500 Reviews',   desc: 'Complete 500 reviews' },
    ],
    // ── Practice Mode ──────────────────────────────────────────────────────
    practiceBtn:           'Practice',
    practiceNoWords:       'No words studied yet — learn some first!',
    practiceMCWordToZh:    'Select the correct meaning',
    practiceMCZhToWord:    'Select the correct English word',
    practiceMCAudioToWord: 'Listen and pick the word',
    practiceSpelling:      'Complete the spelling',
    practiceTrueFalse:     'True or False?',
    practiceHint:          'Hint: ',
    practiceInputPh:       'Type the complete word…',
    practiceSubmit:        'Submit',
    practiceNext:          'Next →',
    practiceTrueBtn:       '✓ True',
    practiceFalseBtn:      '✗ False',
    practiceMatching:      'Match · tap left then right to pair',
    practiceCorrect:       '✓ Correct!',
    practiceWrong:         '✗ Wrong',
    practiceCorrectAns:    'Correct: ',
    practiceDoneTitle:     'Practice Complete!',
    practiceDoneScore:     (c, t) => `${c} / ${t} correct`,
    practiceDoneBack:      'Back',
    practiceWrongTitle:    'Words to reinforce',
    shareBtn:              'Share',
    shareHint:             'Show friends your progress',
    shareCopied:           'Copied — go share!',
    shareCopyFallback:     'Copy to share:',
    obTagline:       'Spaced Repetition Vocabulary · Science-backed',
    obSrsTitle:      '🧠 Science of Memory',
    obSrsDesc:       'Built on Spaced Repetition (SRS) — new words appear often, mastered words at longer intervals. The system shows each word at the perfect moment, so you retain more with less effort.',
    obDecksTitle:    '📚 Four Vocabulary Decks',
    obDeckPetDesc:   'Cambridge PET exam core vocabulary',
    obDeckDailyDesc: 'Business phrases · Internet slang · Daily expressions',
    obDeckIeltsDesc: 'IELTS academic vocabulary · B2–C1 core words',
    obDeckCryptoDesc:'Blockchain · DeFi · Web3 terminology',
    obHowTitle:      '🃏 How to Use',
    obStep1:         'See a word, recall its meaning, tap to flip',
    obStep2:         'Rate yourself: Again / Hard / Good / Easy',
    obStep3:         'Study daily — the system schedules optimal reviews',
    obCta:           'Start Learning →',
    obSkip:          'Skip',
    dwStreakEmoji:   n => n >= 30 ? '🏆' : n >= 14 ? '🔥' : n >= 7 ? '✨' : '🌱',
    dwStreakLabel:   n => `Day ${n}`,
    dwSubtitle:      n => n >= 30 ? `${n} days strong — you're a true learning champion!` : n >= 14 ? `${n} days in — you're on fire!` : n >= 7 ? `${n} days — a habit is forming!` : `${n} days and counting. Keep it up!`,
    dwCta:           'Keep Learning →',
    slideshowStart:  '▷ Auto Play',
    slideshowStop:   '⏸ Stop',
    practicePlayAgain:     'Play again',
    practiceExitBtn:       'Exit Practice',
    undoBtn:               '↩ Undo',
    wlNew:     '🆕 Not Yet Learned',
    wlLearn:   '📖 Learning (active + early review)',
    wlReview:  '🔁 Deep Memory (interval ≥ 21 days)',
    wlMastered:'🏆 Fully Mastered',
    wlEmpty:   'No words here',
    wlClose:   'Close',
    readingBtn:      'Story',
    readingTitle:    "Today's Vocab Story",
    readingClose:    'Close',
    readingKeyInfo:  'A free Gemini API Key is needed to generate the story',
    readingKeyLink:  'Get your free key →',
    readingKeyPh:    'Paste your Gemini API Key',
    readingKeySave:  'Save & Generate',
    readingLoading:  'AI is writing…',
    readingError:    'Generation failed, please retry',
    readingErr429:   'Too many requests — please wait a minute and try again 🕐',
    readingErrKey:   'API key invalid or unauthorised',
    readingErrNet:   'Network error — please check your connection',
    readingErrTime:  'Request timed out — please retry',
    readingRegen:    'Regenerate',
    readingWordList:     'Words covered:',
    readingHistory:      'History',
    readingHistoryEmpty: 'No stories yet',
    readingPaste:        'Paste',
    readingKeyStep1:     'Go to Google AI Studio to get a free key',
    readingKeyStep2:     'Copy the key and paste it below',
    pwaAndroidDesc: 'Add to home screen for quick access', pwaAndroidInstall: 'Install', pwaAndroidDismiss: 'Dismiss',
    pwaIOSTitle: 'Add VocabLoop to Home Screen', pwaIOSDesc: 'Open it like an app — no browser needed',
    pwaIOSStep1: 'Tap the <em>Share</em> button in the toolbar',
    pwaIOSStep2: 'Scroll down and tap <em>"Add to Home Screen"</em>',
    pwaIOSStep3: 'Tap <em>"Add"</em> in the top-right corner',
    pwaIOSDismiss: 'Got it',
    syncBtn: 'Sync', syncSyncing: 'Syncing…', syncDone: 'Synced', syncFail: 'Sync failed',
    syncPull: 'Pulling cloud data…', syncPush: 'Uploading data…',
    syncMerged: 'Merged cloud and local data', syncNoAccount: 'Please log in to sync your progress',
    syncTokenExpired: 'Session expired, please log in again',
    syncUpToDate: 'Up to date', syncLastSync: (t) => `Last sync: ${t}`,
  },
};
const UI = STRINGS[LANG];

// ── Constants ──────────────────────────────────────────────────────────────
const DECKS = [
    { id: 'pet',    icon: '📚', name: UI.deckPET,    file: 'data/pet-words-1000.json' },
    { id: 'daily',  icon: '💬', name: UI.deckDaily,  file: 'data/daily-words-1000.json' },
    { id: 'ielts',  icon: '🎓', name: UI.deckIELTS,  file: 'data/ielts-words.json' },
    { id: 'crypto', icon: '₿',  name: UI.deckCrypto, file: 'data/crypto-words-1000.json' },
];
const DECK_PREF_KEY = 'preferred_deck';
const DICT_KEY      = 'shared_dict_v1';
const MAX_NEW_DAY   = 20;
const LEARN_STEPS   = [1, 5, 10];  // minutes — 3 steps for better initial retention
const GRAD_INT      = 1;         // days
const EASY_INT      = 4;         // days
const MAX_INTERVAL  = 180;       // days — cap review interval; beyond this auto-master
const SESSION_MINS  = 20;        // re-add to session if ≤ this many minutes
const DICT_API      = 'https://api.dictionaryapi.dev/api/v2/entries/en/';
const PREFETCH_N    = 5;         // prefetch ahead N words

// Guard against concurrent duplicate fetches (outside Vue, not reactive)
const _fetching = new Set();

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function ts()    { return Date.now(); }
function today() {
    const d = new Date();
    return d.getFullYear() + '-' +
           String(d.getMonth() + 1).padStart(2, '0') + '-' +
           String(d.getDate()).padStart(2, '0');
}
function fmtMs(ms) {
    if (ms <= 0) return UI.now;
    const m = Math.round(ms / 60000);
    if (m < 60) return m + UI.min;
    const d = Math.round(ms / 86400000);
    return d + UI.day;
}

const POS_ZH = {
    noun: '名词', verb: '动词', adjective: '形容词',
    adverb: '副词', pronoun: '代词', preposition: '介词',
    conjunction: '连词', interjection: '感叹词', exclamation: '感叹词',
    article: '冠词', determiner: '限定词', number: '数词',
    abbreviation: '缩写',
};

const LEVELS         = UI.levels;
const GLOBAL_KEY     = 'srs_global_v1';
const ACHIEVEMENTS   = UI.achievements;
const AGAIN_MSGS     = UI.againMsgs;
const GOOD_MSGS      = UI.goodMsgs;
const EASY_MSGS      = UI.easyMsgs;
const STREAK_TOASTS  = UI.streakToasts;
const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ── Feedback sounds (Web Audio API, no external files) ────────────────────────
function playFeedbackSound(type) {
    try {
        const ctx  = new (window.AudioContext || window.webkitAudioContext)();
        const osc  = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        const t = ctx.currentTime;
        if (type === 'correct') {
            // Soft two-note ascending chime ♪
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, t);
            osc.frequency.setValueAtTime(1320, t + 0.07);
            gain.gain.setValueAtTime(0.10, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
            osc.start(t); osc.stop(t + 0.28);
        } else {
            // Soft low descending tone ♩
            osc.type = 'sine';
            osc.frequency.setValueAtTime(320, t);
            osc.frequency.exponentialRampToValueAtTime(160, t + 0.18);
            gain.gain.setValueAtTime(0.10, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
            osc.start(t); osc.stop(t + 0.22);
        }
        osc.onended = () => ctx.close();
    } catch (_) { /* AudioContext unavailable (e.g. server-side) */ }
}

// ── Practice Mode utilities ───────────────────────────────────────────────────
const MAX_PRACTICE = 20;

/** Return up to n random words from pool that are not target */
function getDistractors(target, pool, n) {
    return shuffle(pool.filter(w => w.word !== target.word)).slice(0, n);
}

/**
 * Build a partial-word hint: keep first letter, blank ~38% of the rest.
 * e.g. "abundant" → "a_und_nt"
 */
function makePartialWord(word) {
    const n = word.length;
    if (n <= 2) return word[0] + '_';
    const blankCount = Math.max(1, Math.round((n - 1) * 0.38));
    const positions  = shuffle([...Array(n - 1).keys()].map(i => i + 1));
    const blanks     = new Set(positions.slice(0, blankCount));
    return [...word].map((l, i) => blanks.has(i) ? '_' : l).join('');
}

/** Normalise Chinese: take the last part after " / " separator */
function shortZh(zh) { return (zh || '').split(' / ').pop().trim(); }

/**
 * Q_GENERATORS — data-driven question type registry.
 * Each entry: (word, pool, dictCache) → question object | null
 * Add future types here; the template handles each by its `type` key.
 */
const Q_GENERATORS = {

    'mc-word-to-zh': function(word, pool) {
        const dist = getDistractors(word, pool, 3);
        if (dist.length < 3) return null;
        return {
            type:    'mc-word-to-zh',
            word,
            correct: word.word,
            options: shuffle([word, ...dist]).map(w => ({ label: shortZh(w.zh), value: w.word })),
        };
    },

    'mc-zh-to-word': function(word, pool) {
        const dist = getDistractors(word, pool, 3);
        if (dist.length < 3) return null;
        return {
            type:    'mc-zh-to-word',
            word,
            correct: word.word,
            options: shuffle([word, ...dist]).map(w => ({ label: w.word, value: w.word })),
        };
    },

    'mc-audio-to-word': function(word, pool, cache) {
        const entry = cache && cache[word.word];
        if (!entry || !entry.audio) return null;
        const dist = getDistractors(word, pool, 3);
        if (dist.length < 3) return null;
        return {
            type:    'mc-audio-to-word',
            word,
            correct: word.word,
            options: shuffle([word, ...dist]).map(w => ({ label: w.word, value: w.word })),
        };
    },

    'spelling': function(word) {
        return {
            type:    'spelling',
            word,
            correct: word.word.toLowerCase(),
            partial: makePartialWord(word.word),
        };
    },

    'truefalse': function(word, pool) {
        const isTrue = Math.random() > 0.5;
        let displayZh;
        if (isTrue) {
            displayZh = shortZh(word.zh);
        } else {
            const dist = getDistractors(word, pool, 1);
            if (!dist.length) return null;
            displayZh = shortZh(dist[0].zh);
        }
        return {
            type:      'truefalse',
            word,
            correct:   isTrue ? 'true' : 'false',
            displayZh,
        };
    },

    'matching': function(word, pool) {
        const dist = getDistractors(word, pool, 5);
        if (dist.length < 5) return null;
        const pairs = shuffle([word, ...dist]);
        return {
            type:       'matching',
            word,
            correct:    'done',
            pairs,
            leftItems:  pairs.map(w => ({ label: w.word, key: w.word })),
            rightItems: shuffle(pairs.map(w => ({ label: shortZh(w.zh), key: w.word }))),
        };
    },
};

/**
 * Build a practice session from todayWords.
 * Uses allWords as the distractor pool to ensure enough options even for small today-sets.
 * Generates 1–2 question types per word, shuffles all questions, caps at MAX_PRACTICE.
 */
function buildPracticeSession(todayWords, allWords, dictCache) {
    if (todayWords.length < 2) return [];
    const pool       = allWords.length >= 8 ? allWords : todayWords;
    const singleTypes = Object.keys(Q_GENERATORS).filter(t => t !== 'matching');
    const questions  = [];

    for (const w of todayWords) {
        const quota  = todayWords.length > 5 ? 2 : 1;
        const picked = shuffle([...singleTypes]).slice(0, quota);
        for (const t of picked) {
            const q = Q_GENERATORS[t](w, pool, dictCache);
            if (q) questions.push(q);
        }
    }
    // Add one matching round if the pool is large enough (needs 5 distractors)
    if (pool.length >= 6) {
        const anchor = shuffle([...todayWords])[0];
        const mq = Q_GENERATORS['matching'](anchor, pool, dictCache);
        if (mq) questions.push(mq);
    }
    return shuffle(questions).slice(0, MAX_PRACTICE);
}

// ── Vue instance ────────────────────────────────────────────────────────────
new Vue({
    el: '#app',
    data() {
        return {
            decks:        DECKS,
            currentDeck:  DECKS[0],
            loading:      true,
            allWords:     [],
            state:        {},
            queue:        [],
            sessionQueue: [],  // full set of words introduced this session (for list view)
            sessionTotal: 0,
            flipped:      false,
            shaking:      false,
            bouncing:     false,
            toast:        null,
            toastTmr:     null,
            points:       0,
            streak:       0,
            viewMode:      'card',
            expandedWords: {},
            autoPlay:      true,
            audioPlaying:  false,
            dictCache:     {},  // word → {ipa, audio, pos, definition, example} | null
            // ── Global gamification ──────────────────────────────────────
            dailyStreak:      0,
            lastStudyDate:    '',
            totalReviewed:    0,
            achievements:     [],
            // ── Session ───────────────────────────────────────────────────
            extraNewAllowed:  0,  // cumulative extra new cards from loadMore
            sessionCorrect:   0,  // all correct answers this session (incl. learning)
            stageLabel:  Object.assign({}, UI.stages),
            ui:          UI,      // exposes all i18n strings to the template
            // ── Practice Mode ──────────────────────────────────────────────
            practiceMode:     false,
            practiceQueue:    [],
            practiceIndex:    0,
            practiceScore:    0,
            practiceAnswered: false,
            practiceSelected: null,
            practiceInput:    '',
            practiceResult:   null,   // 'correct' | 'wrong'
            practiceDone:     false,
            practiceWrongWords: [],   // word objects answered incorrectly
            // ── Matching question state ───────────────────────────────
            matchSelLeft:  null,      // key of selected left item
            matchElim:     [],        // keys of matched pairs
            matchShakeKeys:[],        // keys currently shaking (wrong match)
            // ── Reading overlay ──────────────────────────────────────
            readingOpen:     false,
            readingArticle:  '',
            readingLoading:  false,
            readingError:    '',
            readingWordObjs: [],
            geminiKey:           localStorage.getItem('gemini_key') || '',
            geminiKeyInput:      '',
            readingHistory:      JSON.parse(localStorage.getItem('reading_history') || '[]'),
            readingHistoryOpen:  false,
            // ── Undo ────────────────────────────────────────────────────
            undoSnap:  null,   // pre-answer snapshot
            showUndo:  false,  // undo button visibility
            wordListModal: null, // { stageGroup, title, words } — word list bottom sheet
            showOnboarding: false,
            showDailyWelcome: false,
            slideshowMode:   false,
            slideshowQueue:  [],
            slideshowIdx:    0,
            slideshowWord:   null,
            _slideshowTimer: null,
            dailyWelcomeDay: 0,
            dailyWelcomeQuote: null,
            backendAvailable: false,
        };
    },

    computed: {
        storageKey() { return 'srs_' + this.currentDeck.id + '_v1'; },
        curZhParts() {
            const zh = this.cur.zh || '';
            const idx = zh.indexOf(' / ');
            if (idx !== -1) {
                return { full: zh.slice(0, idx), zh: zh.slice(idx + 3) };
            }
            return { full: '', zh };
        },
        // Example: prefer API result, fall back to JSON ex field
        curExample() {
            if (this.curDict && this.curDict.example) return { text: this.curDict.example, src: 'dict' };
            if (this.cur && this.cur.ex) return { text: this.cur.ex, src: 'json' };
            return null;
        },
        // Second example (inflected form) — from JSON ex2 field
        curExample2() {
            if (this.cur && this.cur.ex2) return this.cur.ex2;
            return null;
        },
        // Abbreviation/acronym note (e.g. "short for Decentralized Finance")
        curNote() {
            if (this.cur && this.cur.note) return this.cur.note;
            return null;
        },
        levelProgress() {
            const mc  = this.masteredCount;
            const lv  = this.levelInfo;
            const idx = LEVELS.indexOf(lv);
            const nxt = LEVELS[idx + 1];
            if (!nxt) return 100;
            const base = (mc - lv.min) / (nxt.min - lv.min) * 100;
            // First level only: add a small review-based boost so day-1 users
            // see immediate progress (caps at 12% so mastery always feels bigger)
            const reviewBoost = idx === 0 ? Math.min(12, this.totalReviewed * 0.5) : 0;
            return Math.min(100, Math.max(0, Math.round(base + reviewBoost)));
        },
        nextLevelInfo() {
            const idx = LEVELS.indexOf(this.levelInfo);
            return LEVELS[idx + 1] || null;
        },
        todayLearnedCount() {
            const tdy = today();
            return Object.values(this.state).filter(s => s && s.firstSeen === tdy).length;
        },
        sessionDone() { return !this.loading && this.queue.length === 0; },
        cur()  { return this.slideshowWord || this.queue[0] || { word: '', zh: '', pos: '' }; },
        curStage() {
            const s = this.state[this.cur.word];
            return s ? (s.stage || 'new') : 'new';
        },
        curDict() {
            if (!this.cur.word) return undefined;
            const v = this.dictCache[this.cur.word];
            return v !== undefined ? v : undefined;
        },
        sessionPct() {
            if (!this.sessionTotal) return 100;
            return Math.round((1 - this.queue.length / this.sessionTotal) * 100);
        },
        listLearnItems() {
            return this.sessionQueue.filter(w => {
                const s = this.state[w.word];
                return !s || s.stage === 'new' || s.stage === 'learning' || s.stage === 'relearn';
            });
        },
        listReviewItems() {
            return this.sessionQueue.filter(w => {
                const s = this.state[w.word];
                return s && (s.stage === 'young' || s.stage === 'mature');
            });
        },
        masteredCount() {
            // Iterate allWords (not Object.values(state)) to ensure stable Vue 2 dep tracking.
            // state also contains _milestone_* keys which are not word objects.
            let n = 0;
            for (const w of this.allWords) {
                const s = this.state[w.word];
                if (s && s.stage === 'mastered') n++;
            }
            return n;
        },
        levelInfo() {
            const n = this.masteredCount;
            let lv = LEVELS[0];
            for (const l of LEVELS) { if (n >= l.min) lv = l; }
            return lv;
        },
        qs() {
            // Count ALL words in deck by stage (not just today's queue)
            // learning/relearn/young → "in learning" (learning phase + early review, 1min–21d)
            // mature                → "in review"   (well-established, interval > 21d)
            let newCount = 0, learnCount = 0, reviewCount = 0;
            for (const w of this.allWords) {
                const s = this.state[w.word];
                if (!s || s.stage === 'new')                                         newCount++;
                else if (s.stage === 'learning' || s.stage === 'relearn' || s.stage === 'young') learnCount++;
                else if (s.stage === 'mature')                                       reviewCount++;
                // mastered counted by masteredCount
            }
            return { newCount, learnCount, reviewCount };
        },
        practiceCurrent() {
            return this.practiceQueue[this.practiceIndex] || null;
        },
        pracScorePct() {
            if (!this.practiceQueue.length) return 0;
            return Math.round(this.practiceScore / this.practiceQueue.length * 100);
        },
        pctColorClass() {
            const p = this.pracScorePct;
            return p >= 80 ? 'pct-green' : p >= 50 ? 'pct-amber' : 'pct-red';
        },
        pracScoreEmoji() {
            const p = this.pracScorePct;
            return p >= 100 ? '🏆' : p >= 80 ? '🎉' : p >= 50 ? '👍' : '💪';
        },
        /** Count cards due within the next 24 hours (but not already overdue/in queue) */
        tomorrowDueCount() {
            const now    = Date.now();
            const in24h  = now + 86400000;
            let n = 0;
            for (const w of this.allWords) {
                const s = this.state[w.word];
                if (s && s.stage !== 'mastered' && s.stage !== 'new') {
                    const next = s.next || 0;
                    if (next > now && next <= in24h) n++;
                }
            }
            return n;
        },
        /** Session accuracy percentage */
        sessionAccuracyPct() {
            const answered = this.sessionCorrect + (this.totalReviewed - (this._sessionReviewedStart || 0)) - this.sessionCorrect;
            // Simpler: derive from progress bar — sessionCorrect out of sessionTotal
            if (!this.sessionTotal || this.sessionTotal <= 1) return 0;
            return Math.round(this.sessionCorrect / this.sessionTotal * 100);
        },
        highlightedArticle() {
            if (!this.readingArticle) return '';
            // Escape HTML first
            let html = this.readingArticle
                .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            // Sort words longest-first to avoid partial replacements
            const words = [...this.readingWordObjs].sort((a, b) => b.word.length - a.word.length);
            for (const w of words) {
                const esc = w.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                html = html.replace(new RegExp(`\\b(${esc})\\b`, 'gi'),
                    `<strong class="vocab-hl" data-word="${w.word}">$1</strong>`);
            }
            return html;
        },
    },

    watch: {
        // When a new card appears: fetch its dict data and prefetch ahead
        'cur.word'(newWord) {
            if (!newWord) return;
            this._preloadAudio(newWord);
            // After dict fetch completes, upgrade current card to Free Dict audio if available
            this.fetchDict(newWord).then(() => this._preloadAudio(newWord));
            this.prefetchAhead();
            if (this.autoPlay) {
                setTimeout(() => this.playAudio(newWord), 200);
            }
        },
        // Silent full sync when study session completes
        sessionDone(done) {
            if (done && this.backendAvailable && window.__vocabSync) {
                window.__vocabSync.doSync();
            }
        },
    },

    methods: {
        // ── Interval display ──────────────────────────────────────────────
        iv(level) {
            const wordId = this.cur.word;
            const s      = this.state[wordId];
            const stage  = s ? (s.stage || 'new') : 'new';
            const step   = s ? (s.learningStep || 0) : 0;
            const intv   = s ? (s.interval || 0) : 0;
            const ef     = s ? (s.ef || 2.5) : 2.5;

            if (stage === 'new' || stage === 'learning') {
                if (level === 'again') return fmtMs(LEARN_STEPS[0] * 60000);
                if (level === 'hard')  return fmtMs(LEARN_STEPS[Math.max(0, step - 1)] * 60000);
                if (level === 'good') {
                    if (step >= LEARN_STEPS.length - 1) return GRAD_INT + UI.day;
                    return fmtMs(LEARN_STEPS[step + 1] * 60000);
                }
                if (level === 'easy') return '✓';
            }
            if (stage === 'relearn') {
                if (level === 'again') return fmtMs(10 * 60000);
                if (level === 'easy')  return '✓';
                return Math.max(1, Math.round(intv * 0.5)) + UI.day;
            }
            if (level === 'again') return fmtMs(10 * 60000);
            if (level === 'hard')  { const d = Math.round(intv * 1.2); return d >= MAX_INTERVAL ? '✓' : d + UI.day; }
            if (level === 'good')  { const d = Math.round(intv * ef);  return d >= MAX_INTERVAL ? '✓' : d + UI.day; }
            if (level === 'easy')  return '✓';
            return '—';
        },

        posZh(pos) {
            if (!pos) return '';
            if (LANG === 'zh') return POS_ZH[pos.toLowerCase()] || pos;
            // English: capitalise first letter of full API words, pass abbreviations through
            return pos.length > 4 ? pos.charAt(0).toUpperCase() + pos.slice(1) : pos;
        },
        achIcon(id) {
            const a = ACHIEVEMENTS.find(x => x.id === id);
            return a ? a.icon : '';
        },
        wlDotClass(word) {
            const s = this.state[word];
            if (!s || s.stage === 'new') return 'wl-dot-new';
            if (s.stage === 'learning' || s.stage === 'relearn') return 'wl-dot-learn';
            return 'wl-dot-review';
        },
        toggleListWord(word) {
            if (this.expandedWords[word]) {
                this.$delete(this.expandedWords, word);
            } else {
                this.$set(this.expandedWords, word, true);
                this.fetchDict(word);
                if (this.autoPlay) this.playAudio(word);
            }
        },

        // ── Dictionary API ────────────────────────────────────────────────
        async fetchDict(word) {
            if (!word) return;
            if (word in this.dictCache) return;
            // Multi-word phrases aren't supported by the dictionary API
            if (word.includes(' ')) {
                this.$set(this.dictCache, word, null);
                return;
            }
            if (_fetching.has(word)) return;
            _fetching.add(word);
            try {
                const res = await fetch(DICT_API + encodeURIComponent(word));
                if (!res.ok) {
                    this.$set(this.dictCache, word, null);
                } else {
                    const data = await res.json();
                    const entry = data[0] || {};
                    const phonetics = entry.phonetics || [];

                    const ipaObj  = phonetics.find(p => p.text && p.text.includes('/'));
                    const ipa     = (ipaObj && ipaObj.text) || entry.phonetic || '';
                    const audioObj = phonetics.find(p => p.audio && p.audio !== '');
                    const audio    = (audioObj && audioObj.audio) || '';

                    let pos = '', definition = '', example = '';
                    for (const m of (entry.meanings || [])) {
                        if (!pos) pos = m.partOfSpeech || '';
                        for (const def of (m.definitions || [])) {
                            if (!definition) definition = def.definition || '';
                            if (!example && def.example) {
                                example = def.example;
                                break;
                            }
                        }
                        if (example) break;
                    }

                    this.$set(this.dictCache, word, { ipa, audio, pos, definition, example });
                    this.saveDictCache();
                }
            } catch (e) {
                this.$set(this.dictCache, word, null);
            } finally {
                _fetching.delete(word);
            }
        },

        prefetchAhead() {
            // Cancel pending audio preload timers from previous card
            this._prefetchTimers.forEach(t => clearTimeout(t));
            this._prefetchTimers = [];

            const upcoming = this.queue.slice(0, PREFETCH_N + 1);
            // Dict fetch: immediate for all (needed for IPA / UI display)
            upcoming.forEach(w => this.fetchDict(w.word));

            // Audio preload: skip queue[0] (current card — handled by watcher).
            // Start earlier, stagger tightly so next cards are ready sooner.
            upcoming.slice(1).forEach((w, i) => {
                const t = setTimeout(() => {
                    this._preloadAudio(w.word);
                    this.fetchDict(w.word).then(() => this._preloadAudio(w.word));
                }, 500 + i * 500);
                this._prefetchTimers.push(t);
            });
        },

        // Preload audio for a word into _audioPreloads cache.
        // Called immediately (uses Youdao) and again after fetchDict (upgrades to Free Dict).
        _preloadAudio(word) {
            if (!word || word.includes(' ')) return;
            const d = this.dictCache[word];
            const url = (d && d.audio)
                || `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=2`;
            const existing = this._audioPreloads[word];
            // Don't replace already-buffered audio (even if a "better" URL is available)
            if (existing && (existing.readyState >= 2 || existing._preloadSrc === url)) return;
            const a = new Audio();
            a.preload = 'auto';
            a.src = url;
            a._preloadSrc = url;
            a.load();
            this._audioPreloads[word] = a;
        },

        // ── Audio ─────────────────────────────────────────────────────────
        // Try playing a URL; resolves true on success, false on failure
        _tryAudioUrl(url) {
            return new Promise(resolve => {
                const a = new Audio(url);
                a.onended = () => { this.audioPlaying = false; };
                a.onerror = () => resolve(false);
                a.play().then(() => resolve(true)).catch(() => resolve(false));
            });
        },

        // Plays audio and waits until it ENDS (for slideshow auto-flip)
        async _playAndWait(word) {
            if (!word) return;
            this.audioPlaying = true;
            const waitEndEl = (el) => new Promise(resolve => {
                el.currentTime = 0;
                el.onended = () => { this.audioPlaying = false; resolve(true); };
                el.onerror = () => resolve(false);
                el.play().catch(() => resolve(false));
            });
            const waitEnd = (url) => new Promise(resolve => {
                const a = new Audio(url);
                a.onended = () => { this.audioPlaying = false; resolve(true); };
                a.onerror = () => resolve(false);
                a.play().catch(() => resolve(false));
            });
            // 0. Preloaded audio — play instantly or wait briefly for in-progress preload
            const preloaded = this._audioPreloads && this._audioPreloads[word];
            if (preloaded) {
                if (preloaded.readyState >= 2) {
                    if (await waitEndEl(preloaded)) return;
                } else {
                    const ready = await new Promise(r => {
                        if (preloaded.readyState >= 2) return r(true);
                        preloaded.addEventListener('canplaythrough', () => r(true), { once: true });
                        preloaded.addEventListener('error', () => r(false), { once: true });
                        setTimeout(() => r(false), 1500);
                    });
                    if (ready && await waitEndEl(preloaded)) return;
                }
            }
            const d = this.dictCache[word];
            if (d && d.audio && await waitEnd(d.audio)) return;
            const youdao = `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=2`;
            if (await waitEnd(youdao)) return;
            this.audioPlaying = false;
            // TTS fallback — wait for speech end
            await new Promise(resolve => {
                if (!('speechSynthesis' in window)) { resolve(); return; }
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance(word);
                u.lang = 'en-US'; u.rate = 0.85;
                const voices = speechSynthesis.getVoices();
                const PREF = ['Google US English',
                    'Microsoft Aria Online (Natural) - English (United States)',
                    'Samantha', 'Alex'];
                const best = PREF.map(n => voices.find(v => v.name === n)).find(Boolean)
                    || voices.find(v => v.lang === 'en-US' && !v.localService)
                    || voices.find(v => v.lang.startsWith('en'));
                if (best) u.voice = best;
                this.audioPlaying = true;
                u.onend  = () => { this.audioPlaying = false; resolve(); };
                u.onerror = () => { this.audioPlaying = false; resolve(); };
                speechSynthesis.speak(u);
            });
        },

        // ── Slideshow (auto-play) mode ──────────────────────────────
        toggleView() {
            this.stopSlideshow();
            this.viewMode = this.viewMode === 'card' ? 'list' : 'card';
        },
        toggleSlideshow() {
            this.slideshowMode ? this.stopSlideshow() : this.startSlideshow();
        },
        startSlideshow() {
            // Use current SRS queue (all today's pending words);
            // fall back to today's practiced words if session is already done.
            const words = this.queue.length ? [...this.queue] : this.getTodayPracticeWords();
            if (!words.length) return;
            this.slideshowQueue = words;
            this.slideshowIdx   = 0;
            this.slideshowMode  = true;
            this.flipped        = false;
            this._slideshowStep();
        },
        async _slideshowStep() {
            if (!this.slideshowMode) return;
            this.slideshowWord = this.slideshowQueue[this.slideshowIdx];
            this.flipped       = false;
            await new Promise(r => setTimeout(r, 500));
            if (!this.slideshowMode) return;
            await this._playAndWait(this.slideshowWord.word);
            if (!this.slideshowMode) return;
            // Audio finished — safe to preload upcoming cards without competing
            this.slideshowQueue
                .slice(this.slideshowIdx + 1, this.slideshowIdx + 1 + PREFETCH_N)
                .forEach((w, i) => {
                    setTimeout(() => {
                        this._preloadAudio(w.word);
                        this.fetchDict(w.word).then(() => this._preloadAudio(w.word));
                    }, i * 800);
                });
            this.flipped = true;
            this._slideshowTimer = setTimeout(() => {
                if (!this.slideshowMode) return;
                this.slideshowIdx++;
                if (this.slideshowIdx >= this.slideshowQueue.length) {
                    this.stopSlideshow(); return;
                }
                this._slideshowStep();
            }, 5000);
        },
        stopSlideshow() {
            clearTimeout(this._slideshowTimer);
            this._slideshowTimer = null;
            this.slideshowMode   = false;
            this.slideshowWord   = null;
            this.flipped         = false;
        },

        async playAudio(word) {
            if (!word) return;
            this.audioPlaying = true;

            // 0. Preloaded audio — play instantly or wait briefly for in-progress preload
            const preloaded = this._audioPreloads && this._audioPreloads[word];
            if (preloaded) {
                if (preloaded.readyState >= 2) {
                    preloaded.currentTime = 0;
                    preloaded.onended = () => { this.audioPlaying = false; };
                    try { await preloaded.play(); return; } catch(e) { /* fall through */ }
                } else {
                    // Audio is preloading — wait up to 1.5s for it to buffer, then fall through
                    const ready = await new Promise(r => {
                        if (preloaded.readyState >= 2) return r(true);
                        preloaded.addEventListener('canplaythrough', () => r(true), { once: true });
                        preloaded.addEventListener('error', () => r(false), { once: true });
                        setTimeout(() => r(false), 1500);
                    });
                    if (ready) {
                        preloaded.currentTime = 0;
                        preloaded.onended = () => { this.audioPlaying = false; };
                        try { await preloaded.play(); return; } catch(e) { /* fall through */ }
                    }
                }
            }

            // 1. Free Dictionary API — human recordings for common words
            const d = this.dictCache[word];
            if (d && d.audio) {
                if (await this._tryAudioUrl(d.audio)) return;
            }

            // 2. Youdao Dictionary — professional TTS, wide coverage incl. phrases & tech terms
            const youdao = `https://dict.youdao.com/dictvoice?audio=${encodeURIComponent(word)}&type=2`;
            if (await this._tryAudioUrl(youdao)) return;

            // 3. Browser TTS — best available voice as last resort
            this.audioPlaying = false;
            this.tts(word);
        },

        tts(word) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(word);
            u.lang = 'en-US';
            u.rate = 0.85;
            // Prefer high-quality cloud/neural voices over local system voices
            const voices = speechSynthesis.getVoices();
            const PREF = [
                'Google US English',
                'Microsoft Aria Online (Natural) - English (United States)',
                'Microsoft Ana Online (Natural) - English (United States)',
                'Microsoft Jenny Online (Natural) - English (United States)',
                'Samantha', 'Alex', 'Karen',
            ];
            const best = PREF.map(n => voices.find(v => v.name === n)).find(Boolean)
                || voices.find(v => v.lang === 'en-US' && !v.localService)
                || voices.find(v => v.lang.startsWith('en'));
            if (best) u.voice = best;
            this.audioPlaying = true;
            u.onend  = () => { this.audioPlaying = false; };
            u.onerror = () => { this.audioPlaying = false; };
            window.speechSynthesis.speak(u);
        },

        // ── Load JSON ─────────────────────────────────────────────────────
        async loadWords() {
            this.loading = true;
            try {
                const res = await fetch(this.currentDeck.file);
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const data = await res.json();
                this.allWords = data.map(w => ({
                    word: w.word,
                    zh:   w.zh || w.word,
                    pos:  w.pos || '',
                    ipa:  w.ipa || '',
                    ex:   w.ex  || '',
                    ex2:  w.ex2 || '',
                    note: w.note || '',
                }));
                // Pre-seed dictCache from embedded word data (single batch update)
                const additions = {};
                for (const w of this.allWords) {
                    if (!(w.word in this.dictCache) && (w.ipa || w.pos || w.ex || w.ex2)) {
                        additions[w.word] = {
                            ipa:        w.ipa,
                            audio:      '',
                            pos:        w.pos,
                            definition: w.zh,
                            example:    w.ex,
                            example2:   w.ex2,
                        };
                    }
                }
                if (Object.keys(additions).length) {
                    this.dictCache = Object.assign({}, this.dictCache, additions);
                }
                this.buildQueue();
                // Eagerly preload first card's audio (Youdao URL is deterministic, no API needed)
                if (this.queue.length) this._preloadAudio(this.queue[0].word);
            } catch (e) {
                alert(UI.loadError(e.message, this.currentDeck.file));
            }
            this.loading = false;
            // Track first and last visit dates
            const todayStr = new Date().toDateString();
            if (!localStorage.getItem('first_visit_date')) {
                try { localStorage.setItem('first_visit_date', todayStr); } catch(e) {}
            }
            // Show onboarding for first-time users; daily welcome for returning users
            if (!localStorage.getItem('onboarding_seen')) {
                this.showOnboarding = true;
            } else {
                const lastVisit = localStorage.getItem('last_visit_date');
                if (lastVisit !== todayStr && this.dailyStreak >= 2) {
                    this.dailyWelcomeDay = this.dailyStreak;
                    this.dailyWelcomeQuote = DAILY_QUOTES[Math.floor(Math.random() * DAILY_QUOTES.length)];
                    this.showDailyWelcome = true;
                }
            }
            try { localStorage.setItem('last_visit_date', todayStr); } catch(e) {}
        },

        // ── Build today's queue ───────────────────────────────────────────
        buildQueue(extraNew = 0) {
            const tdy   = today();
            const state = this.state;
            // Count non-mastered words first-seen today (mastered words don't use up "new" slots)
            let newToday = 0;
            for (const w of this.allWords) {
                const s = state[w.word];
                if (s && s.firstSeen === tdy && s.stage !== 'mastered') newToday++;
            }
            const slots = Math.max(0, MAX_NEW_DAY - newToday + extraNew);

            const reviews  = [];
            const learning = [];
            const newCards = [];

            for (const w of this.allWords) {
                const s = state[w.word];
                if (!s) {
                    if (newCards.length < slots) newCards.push(w);
                } else if (s.stage === 'mastered') {
                    /* never queue mastered words */
                } else if (s.stage === 'learning' || s.stage === 'relearn') {
                    if ((s.next || 0) <= ts()) learning.push(w);
                } else if (s.stage === 'young' || s.stage === 'mature') {
                    if ((s.next || 0) <= ts()) reviews.push(w);
                }
            }

            // Interleave new cards into reviews (1 new per 4 reviews)
            // so users see fresh content throughout instead of all new cards at the end
            const shuffledRev = shuffle(reviews);
            const shuffledNew = shuffle(newCards);
            const interleaved = [];
            let ri = 0, ni = 0;
            while (ri < shuffledRev.length || ni < shuffledNew.length) {
                for (let i = 0; i < 4 && ri < shuffledRev.length; i++) interleaved.push(shuffledRev[ri++]);
                if (ni < shuffledNew.length) interleaved.push(shuffledNew[ni++]);
            }
            const q = [...learning, ...interleaved];
            this.queue        = q;
            this.sessionTotal = q.length || 1;
            // Maintain sessionQueue: reset on fresh build (extraNew=0), extend on loadMore
            if (extraNew === 0) {
                this.sessionQueue = [...q];
            } else {
                const seen = new Set(this.sessionQueue.map(w => w.word));
                this.sessionQueue = [...this.sessionQueue, ...q.filter(w => !seen.has(w.word))];
            }
            this.prefetchAhead();
        },

        // ── Deck switching ────────────────────────────────────────────────
        switchDeck(deck) {
            if (deck.id === this.currentDeck.id) return;
            if (this.practiceMode) this.exitPractice();
            this.saveState();
            this.currentDeck = deck;
            try { localStorage.setItem(DECK_PREF_KEY, deck.id); } catch (e) {}
            this.state           = {};
            this.points          = 0;
            this.streak          = 0;
            this.queue           = [];
            this.flipped         = false;
            this.extraNewAllowed = 0;
            this.sessionCorrect  = 0;
            this.loadSaved();
            this.loadWords();
        },

        // ── Card interaction ──────────────────────────────────────────────
        onCardClick() {
            if (this.slideshowMode) return;
            if (!this.flipped) this.flipCard(); else this.playAudio(this.cur.word);
        },
        flipCard()    { this.flipped = !this.flipped; },

        // ── SRS answer ────────────────────────────────────────────────────
        answer(level) {
            if (!this.flipped || this.slideshowMode) return;

            this.totalReviewed++;
            this.updateDailyStreak();

            const wordId = this.cur.word;
            const tdy    = today();
            let s = this.state[wordId] || {
                stage: 'new', interval: 0, ef: 2.5,
                reps: 0, learningStep: 0, next: 0, firstSeen: tdy,
            };
            if (!s.firstSeen) s.firstSeen = tdy;

            // Save pre-answer snapshot for undo (totalReviewed already incremented above)
            const _undoPrev = {
                wordId,
                prevState:      this.state[wordId] ? { ...this.state[wordId] } : null,
                points:         this.points,
                streak:         this.streak,
                totalReviewed:  this.totalReviewed - 1,
                sessionCorrect: this.sessionCorrect,
            };

            let nextMs;
            let reinsert     = false;
            let newGraduated = false;   // new/learning → young/mature

            if (s.stage === 'new' || s.stage === 'learning') {
                if (level === 'again') {
                    s.learningStep = 0;
                    nextMs   = LEARN_STEPS[0] * 60000;
                    s.stage  = 'learning';
                    reinsert = true;
                    this.streak = 0;
                } else if (level === 'hard') {
                    const step = Math.max(0, (s.learningStep || 0) - 1);
                    s.learningStep = step;
                    nextMs   = LEARN_STEPS[step] * 60000;
                    s.stage  = 'learning';
                    reinsert = nextMs <= SESSION_MINS * 60000;
                    this.points += 5; this.sessionCorrect++;
                } else if (level === 'good') {
                    const step = s.learningStep || 0;
                    if (step >= LEARN_STEPS.length - 1) {
                        s.stage    = 'young';
                        s.interval = GRAD_INT;
                        s.reps     = 1;
                        nextMs     = GRAD_INT * 86400000;
                        this.points += 15; this.sessionCorrect++;
                        newGraduated = true;
                    } else {
                        s.learningStep = step + 1;
                        nextMs   = LEARN_STEPS[s.learningStep] * 60000;
                        s.stage  = 'learning';
                        reinsert = nextMs <= SESSION_MINS * 60000;
                        this.points += 5; this.sessionCorrect++;
                    }
                } else { // easy — fully mastered, never show again
                    s.stage    = 'mastered';
                    s.interval = 9999;
                    s.reps     = 1;
                    nextMs     = 9999 * 86400000;
                    this.points += 20; this.sessionCorrect++;
                    newGraduated = true;
                }

            } else if (s.stage === 'relearn') {
                if (level === 'again') {
                    nextMs   = 10 * 60000;
                    reinsert = true;
                    this.streak = 0;
                } else if (level === 'easy') {
                    s.stage    = 'mastered';
                    s.interval = 9999;
                    nextMs     = 9999 * 86400000;
                } else {
                    s.interval = Math.max(1, Math.round(s.interval * 0.5));
                    s.stage    = s.interval >= 21 ? 'mature' : 'young';
                    nextMs     = s.interval * 86400000;
                }

            } else {
                // young / mature
                if (level === 'again') {
                    s.stage  = 'relearn';
                    s.reps   = 0;
                    nextMs   = 10 * 60000;
                    reinsert = true;
                    this.streak = 0;
                } else {
                    if (level === 'easy') {
                        s.stage    = 'mastered';
                        s.interval = 9999;
                        s.reps     = (s.reps || 0) + 1;
                        nextMs     = 9999 * 86400000;
                        this.points += 30;
                        this.streak += 1;
                        this.sessionCorrect++;
                    } else {
                        const ef = s.ef || 2.5;
                        if (level === 'hard') {
                            s.ef       = Math.max(1.3, ef - 0.15);
                            s.interval = Math.max(1, Math.round(s.interval * 1.2));
                        } else {
                            s.interval = Math.max(1, Math.round(s.interval * ef));
                        }
                        s.reps = (s.reps || 0) + 1;
                        // Cap interval — words known this well are effectively mastered
                        if (s.interval >= MAX_INTERVAL) {
                            s.stage    = 'mastered';
                            s.interval = 9999;
                            nextMs     = 9999 * 86400000;
                        } else {
                            s.stage = s.interval >= 21 ? 'mature' : 'young';
                            nextMs  = s.interval * 86400000;
                        }

                        const pts = level === 'hard' ? 10 : 20;
                        this.points += pts;
                        this.streak += 1;
                        this.sessionCorrect++;
                    }
                }
            }

            s.next = ts() + nextMs;
            this.$set(this.state, wordId, { ...s });
            this.flipped = false;
            this.saveState();
            this.checkAchievements();
            this.saveGlobal();    // always persist totalReviewed + streak

            // Show undo button for 8 seconds (was 4s — longer window to catch mis-clicks)
            this.undoSnap = _undoPrev;
            this.showUndo = true;
            clearTimeout(this._undoTimer);
            this._undoTimer = setTimeout(() => { this.showUndo = false; }, 8000);

            // Feedback
            const ps = this.streak;
            if (level === 'again') {
                this.doShake();
                this.showToast(pick(AGAIN_MSGS), 'bad');
            } else {
                this.doBounce();
                const streakToast = STREAK_TOASTS[ps];
                if (streakToast) {
                    this.showToast(streakToast.msg, streakToast.type);
                    if (newGraduated) {
                        setTimeout(() => this.showToast(UI.graduated, 'bonus'), 2500);
                    }
                } else if (newGraduated) {
                    this.showToast(UI.graduated, 'bonus');
                } else if (level === 'easy') {
                    this.showToast(pick(EASY_MSGS), 'bonus');
                } else {
                    this.showToast(pick(GOOD_MSGS), 'good');
                }
            }

            // Milestone
            const mc = this.masteredCount;
            if (mc > 0 && mc % 50 === 0 && s.stage === 'mastered') {
                const mKey = '_milestone_' + mc;
                if (!this.state[mKey]) {
                    this.$set(this.state, mKey, 1);
                    setTimeout(() => this.showToast(UI.mastered(mc), 'bonus'), 800);
                }
            }

            // Queue management
            if (reinsert) {
                const card = this.queue.shift();
                this.queue.push(card);
            } else {
                this.queue.shift();
            }
        },

        // ── Animations ───────────────────────────────────────────────────
        doShake() {
            this.shaking = false;
            this.$nextTick(() => { this.shaking = true; });
            setTimeout(() => { this.shaking = false; }, 500);
        },
        doBounce() {
            this.bouncing = false;
            this.$nextTick(() => { this.bouncing = true; });
            setTimeout(() => { this.bouncing = false; }, 400);
        },
        showToast(msg, type = 'good') {
            clearTimeout(this.toastTmr);
            this.toast = null;
            this.$nextTick(() => {
                this.toast = { msg, type };
                this.toastTmr = setTimeout(() => { this.toast = null; }, 2400);
            });
        },

        // ── Onboarding ───────────────────────────────────────────────────
        dismissOnboarding() {
            this.showOnboarding = false;
            try { localStorage.setItem('onboarding_seen', '1'); } catch (e) {}
        },

        // ── Daily welcome ─────────────────────────────────────────────────
        openDailyWelcome() {
            this.dailyWelcomeDay = this.dailyStreak;
            this.dailyWelcomeQuote = DAILY_QUOTES[Math.floor(Math.random() * DAILY_QUOTES.length)];
            this.showDailyWelcome = true;
        },
        dismissDailyWelcome() {
            this.showDailyWelcome = false;
        },

        // ── Share ─────────────────────────────────────────────────────────
        _shareUrl() {
            // Auto-detect base URL from current domain (works on any hosting)
            return window.location.origin + window.location.pathname.replace(/[^/]*$/, '');
        },
        shareApp() {
            this._doShare({
                title: 'VocabLoop',
                text: LANG === 'zh'
                    ? '📚 VocabLoop — 间隔重复英语词汇 PWA\nPET / 日常口语 / Crypto 三大词库，科学记单词\n🆓 开源免费，无广告打扰'
                    : '📚 VocabLoop — Spaced Repetition Vocabulary PWA\nPET / Daily English / Crypto — science-backed word learning\n🆓 Open-source, free, no ads',
                url: this._shareUrl(),
            });
        },
        shareSession() {
            const url = this._shareUrl();
            const streakLine = this.dailyStreak >= 2
                ? (LANG === 'zh' ? `🔥 ${this.dailyStreak} 天连续学习\n` : `🔥 ${this.dailyStreak}-day streak\n`)
                : '';
            this._doShare({
                title: LANG === 'zh' ? 'VocabLoop 今日学习完成！' : 'VocabLoop session complete!',
                text: LANG === 'zh'
                    ? `🎉 今日学习完成！\n📖 新学：${this.todayLearnedCount} | ✅ 答对：${this.sessionCorrect} | 🏆 已掌握：${this.masteredCount}\n${streakLine}`
                    : `🎉 Session complete!\n📖 New: ${this.todayLearnedCount} | ✅ Correct: ${this.sessionCorrect} | 🏆 Mastered: ${this.masteredCount}\n${streakLine}`,
                url,
            });
        },
        sharePractice() {
            const url = this._shareUrl();
            const pct = this.practiceQueue.length > 0
                ? Math.round(this.practiceScore / this.practiceQueue.length * 100) : 0;
            this._doShare({
                title: LANG === 'zh' ? 'VocabLoop 练习结束！' : 'VocabLoop practice done!',
                text: LANG === 'zh'
                    ? `✏️ 练习结束！得分：${this.practiceScore}/${this.practiceQueue.length}（${pct}%）`
                    : `✏️ Practice done! Score: ${this.practiceScore}/${this.practiceQueue.length} (${pct}%)`,
                url,
            });
        },
        async _doShare({ title, text, url }) {
            if (navigator.share) {
                try { await navigator.share({ title, text, url }); return; }
                catch (e) { if (e.name === 'AbortError') return; }
            }
            const fullText = `${text}\n→ ${url}`;
            try {
                await navigator.clipboard.writeText(fullText);
                this.showToast(UI.shareCopied, 'good');
            } catch (e) {
                prompt(UI.shareCopyFallback, fullText);
            }
        },

        // ── Persistence ──────────────────────────────────────────────────
        loadSaved() {
            try {
                const raw = localStorage.getItem(this.storageKey);
                if (raw) {
                    const d        = JSON.parse(raw);
                    this.state     = d.state    || {};
                    this.points    = d.points   || 0;
                    this.streak    = d.streak   || 0;
                    this.autoPlay  = d.autoPlay !== undefined ? d.autoPlay : true;
                    // Migrate: promote any young/mature cards with giant intervals to mastered
                    for (const s of Object.values(this.state)) {
                        if (s && (s.stage === 'young' || s.stage === 'mature') && (s.interval || 0) >= MAX_INTERVAL) {
                            s.stage    = 'mastered';
                            s.interval = 9999;
                            s.next     = Date.now() + 9999 * 86400000;
                        }
                    }
                }
            } catch (e) { /* ignore */ }
        },
        saveState() {
            const payload = JSON.stringify({
                state:    this.state,
                points:   this.points,
                streak:   this.streak,
                autoPlay: this.autoPlay,
            });
            try {
                localStorage.setItem(this.storageKey, payload);
            } catch (e) {
                // Quota exceeded: evict dict cache first, then retry
                try {
                    localStorage.removeItem(DICT_KEY);
                    this.dictCache = {};
                    localStorage.setItem(this.storageKey, payload);
                } catch (e2) { /* storage unavailable (e.g. private mode) — give up */ }
            }
        },
        loadDictCache() {
            try {
                const raw = localStorage.getItem(DICT_KEY);
                if (raw) this.dictCache = JSON.parse(raw);
            } catch (e) { /* ignore */ }
        },
        saveDictCache() {
            try {
                localStorage.setItem(DICT_KEY, JSON.stringify(this.dictCache));
            } catch (e) {
                localStorage.removeItem(DICT_KEY);
            }
        },
        async checkBackend() {
            try {
                // Use 'ping' action — does a real DB query to confirm full backend health.
                // Empty-body probe was misleading: it bypassed the DB and falsely showed
                // backendAvailable=true even when TURSO_DATABASE_URL was not configured.
                const res = await fetch('/api/auth', {
                    method: 'POST',
                    headers: { 'content-type': 'application/json' },
                    body: JSON.stringify({ action: 'ping' }),
                });
                const ct = (res.headers.get('content-type') || '');
                if (ct.includes('application/json') || ct.includes('text/json')) {
                    const data = await res.json();
                    this.backendAvailable = !!(data && data.ok === true && data.message === 'pong');
                } else {
                    this.backendAvailable = false;
                }
            } catch (e) {
                this.backendAvailable = false;
            }
            // Expose for sync module (initializes asynchronously)
            window.__backendAvailable = this.backendAvailable;
        },
        confirmReset() {
            if (confirm(UI.confirmReset(this.currentDeck.name))) {
                localStorage.removeItem(this.storageKey);
                this.state  = {};
                this.points = 0;
                this.streak = 0;
                this.buildQueue();
            }
        },
        loadMore() {
            this.extraNewAllowed += MAX_NEW_DAY;
            this.sessionCorrect   = 0;
            this.buildQueue(this.extraNewAllowed);
            if (this.queue.length === 0) {
                // No new/due cards left — re-review today's words
                this.loadTodayReview();
            }
        },
        loadTodayReview() {
            const tdy = today();
            const todayWords = this.allWords.filter(w => {
                const s = this.state[w.word];
                return s && s.firstSeen === tdy;
            });
            if (todayWords.length === 0) {
                alert(UI.noMoreWords);
                return;
            }
            this.sessionCorrect  = 0;
            this.queue           = shuffle([...todayWords]);
            this.sessionTotal    = this.queue.length;
            const seenTR = new Set(this.sessionQueue.map(w => w.word));
            this.sessionQueue = [...this.sessionQueue, ...this.queue.filter(w => !seenTR.has(w.word))];
            this.prefetchAhead();
            this.showToast(UI.reviewToday(todayWords.length), 'good');
        },

        // ── Global state (daily streak, achievements) ─────────────────────
        loadGlobal() {
            try {
                const raw = localStorage.getItem(GLOBAL_KEY);
                if (raw) {
                    const d = JSON.parse(raw);
                    this.dailyStreak   = d.dailyStreak   || 0;
                    this.lastStudyDate = d.lastStudyDate  || '';
                    this.totalReviewed = d.totalReviewed  || 0;
                    this.achievements  = d.achievements   || [];
                }
            } catch (e) { /* ignore */ }
        },
        saveGlobal() {
            try {
                localStorage.setItem(GLOBAL_KEY, JSON.stringify({
                    dailyStreak:   this.dailyStreak,
                    lastStudyDate: this.lastStudyDate,
                    totalReviewed: this.totalReviewed,
                    achievements:  this.achievements,
                }));
            } catch (e) { /* storage unavailable — give up */ }
        },
        updateDailyStreak() {
            const tdy = today();
            if (this.lastStudyDate === tdy) return;
            const d = new Date();
            d.setDate(d.getDate() - 1);
            const yesterday = d.getFullYear() + '-' +
                String(d.getMonth() + 1).padStart(2, '0') + '-' +
                String(d.getDate()).padStart(2, '0');
            if (this.lastStudyDate === yesterday) {
                this.dailyStreak += 1;
            } else {
                this.dailyStreak = 1;
            }
            this.lastStudyDate = tdy;
            // saveGlobal() will be called by answer() after this
        },
        checkAchievements() {
            const earned = [];
            const check = (id, cond) => {
                if (cond && !this.achievements.includes(id)) {
                    this.achievements.push(id);
                    earned.push(id);
                }
            };
            check('first_answer',  this.totalReviewed >= 1);
            check('streak_5',      this.streak >= 5);
            check('streak_20',     this.streak >= 20);
            check('daily_3',       this.dailyStreak >= 3);
            check('daily_7',       this.dailyStreak >= 7);
            check('daily_30',      this.dailyStreak >= 30);
            check('master_1',      this.masteredCount >= 1);
            check('master_10',     this.masteredCount >= 10);
            check('master_100',    this.masteredCount >= 100);
            check('reviewed_100',  this.totalReviewed >= 100);
            check('reviewed_500',  this.totalReviewed >= 500);
            if (earned.length > 0) {
                // saveGlobal() called by answer() — no extra write needed here
                const a = ACHIEVEMENTS.find(x => x.id === earned[earned.length - 1]);
                if (a) {
                    setTimeout(() => this.showToast(UI.achievementUnlocked(a.icon, a.name), 'bonus'), 1200);
                }
            }
        },
        exportProgress() {
            const allState = {};
            for (const deck of DECKS) {
                try {
                    const raw = localStorage.getItem('srs_' + deck.id + '_v1');
                    if (raw) allState[deck.id] = JSON.parse(raw);
                } catch (e) {}
            }
            let readingHistory = [];
            try { const raw = localStorage.getItem('reading_history'); if (raw) readingHistory = JSON.parse(raw); } catch (e) {}
            const data = {
                version:      1,
                exportDate:   new Date().toISOString(),
                global:       {
                    dailyStreak:   this.dailyStreak,
                    lastStudyDate: this.lastStudyDate,
                    totalReviewed: this.totalReviewed,
                    achievements:  this.achievements,
                },
                decks:          allState,
                preferredDeck:  localStorage.getItem(DECK_PREF_KEY) || '',
                readingHistory: readingHistory,
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = 'vocabloop-backup-' + today() + '.json';
            a.click();
            URL.revokeObjectURL(url);
            this.showToast(UI.exportBtn + ' ✓', 'good');
        },
        triggerImport() {
            document.getElementById('importFileInput').click();
        },
        handleImportFile(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const data = JSON.parse(ev.target.result);
                    this.importProgress(data);
                } catch (err) {
                    this.showToast(UI.importFail, 'bad');
                }
                // Reset file input so the same file can be re-imported
                e.target.value = '';
            };
            reader.readAsText(file);
        },
        importProgress(data) {
            // Validate structure
            if (!data || typeof data !== 'object' || !data.decks) {
                this.showToast(UI.importFail, 'bad');
                return;
            }
            if (!confirm(UI.importConfirm)) return;

            let mergedCount = 0;

            // Merge each deck's SRS state at word level
            for (const deck of DECKS) {
                const importedDeck = data.decks[deck.id];
                if (!importedDeck) continue;
                const importedState = importedDeck.state || {};
                if (Object.keys(importedState).length === 0) continue;

                // Load existing local state for this deck
                let localDeck = {};
                try {
                    const raw = localStorage.getItem('srs_' + deck.id + '_v1');
                    if (raw) localDeck = JSON.parse(raw);
                } catch (e) {}
                const localState = localDeck.state || {};

                // Per-word merge: keep version with later next timestamp
                const merged = {};
                const allWords = new Set([...Object.keys(localState), ...Object.keys(importedState)]);
                for (const word of allWords) {
                    const l = localState[word];
                    const c = importedState[word];
                    if (!l) { merged[word] = c; continue; }
                    if (!c) { merged[word] = l; continue; }
                    merged[word] = (l.next || 0) >= (c.next || 0) ? l : c;
                }

                const mergedDeck = {
                    state:    merged,
                    points:   Math.max(localDeck.points || 0, importedDeck.points || 0),
                    streak:   Math.max(localDeck.streak || 0, importedDeck.streak || 0),
                    autoPlay: localDeck.autoPlay !== undefined ? localDeck.autoPlay : importedDeck.autoPlay,
                };

                try { localStorage.setItem('srs_' + deck.id + '_v1', JSON.stringify(mergedDeck)); } catch (e) {}
                mergedCount++;
            }

            // Merge global state
            if (data.global) {
                const g = data.global;
                this.dailyStreak   = Math.max(this.dailyStreak, g.dailyStreak || 0);
                this.lastStudyDate = (this.lastStudyDate || '') >= (g.lastStudyDate || '') ? this.lastStudyDate : g.lastStudyDate;
                this.totalReviewed = Math.max(this.totalReviewed, g.totalReviewed || 0);
                if (Array.isArray(g.achievements)) {
                    this.achievements = [...new Set([...this.achievements, ...g.achievements])];
                }
                this.saveGlobal();
            }

            // Merge reading history
            if (Array.isArray(data.readingHistory) && data.readingHistory.length > 0) {
                let existing = [];
                try { const raw = localStorage.getItem('reading_history'); if (raw) existing = JSON.parse(raw); } catch (e) {}
                const seen = new Set();
                const merged = [];
                for (const item of [...existing, ...data.readingHistory]) {
                    const key = JSON.stringify(item);
                    if (!seen.has(key)) { seen.add(key); merged.push(item); }
                }
                try { localStorage.setItem('reading_history', JSON.stringify(merged.slice(-50))); } catch (e) {}
            }

            // Reload current deck state into Vue
            this.loadSaved();
            this.buildQueue();

            if (mergedCount > 0) {
                this.showToast(UI.importOk(mergedCount), 'good');
            } else {
                this.showToast(UI.importEmpty, 'bad');
            }
        },

        // ── Practice Mode ─────────────────────────────────────────────────
        /** Return today's learned words; fallback to recently reviewed if too few */
        getTodayPracticeWords() {
            const tdy = today();
            // Today's words first (prioritised in practice session)
            const todayWords = this.allWords.filter(w => {
                const s = this.state[w.word];
                return s && s.firstSeen === tdy && s.stage !== 'mastered';
            });
            // All other seen words as supplementary pool
            const otherWords = shuffle(
                this.allWords.filter(w => {
                    const s = this.state[w.word];
                    return s && s.firstSeen !== tdy && s.stage !== 'mastered';
                })
            );
            // Combine: today's words + enough others to reach at least 8 total
            const needed = Math.max(0, 8 - todayWords.length);
            return [...todayWords, ...otherWords.slice(0, needed)];
        },

        startPractice() {
            clearTimeout(this._practiceTimer);
            const words = this.getTodayPracticeWords();
            if (words.length < 2) {
                this.showToast(this.ui.practiceNoWords, 'bad');
                return;
            }
            // Exclude mastered words from the distractor pool so they never appear as options
            const practicePool = this.allWords.filter(w => {
                const s = this.state[w.word];
                return !s || s.stage !== 'mastered';
            });
            const qs = buildPracticeSession(words, practicePool, this.dictCache);
            if (qs.length === 0) {
                this.showToast(this.ui.practiceNoWords, 'bad');
                return;
            }
            this.practiceQueue    = qs;
            this.practiceIndex    = 0;
            this.practiceScore    = 0;
            this.practiceAnswered = false;
            this.practiceSelected = null;
            this.practiceInput    = '';
            this.practiceResult     = null;
            this.practiceDone       = false;
            this.practiceWrongWords = [];
            this.practiceMode       = true;
            this._afterPracticeQuestion();
        },

        exitPractice() {
            clearTimeout(this._practiceTimer);
            // Show a score summary toast when exiting a started (non-done) session
            if (!this.practiceDone) {
                const answered = this.practiceAnswered
                    ? this.practiceIndex + 1
                    : this.practiceIndex;
                if (answered > 0) {
                    this.showToast(this.ui.practiceDoneScore(this.practiceScore, answered), 'good');
                }
            }
            this.practiceMode = false;
        },

        // Undo the most recent SRS answer
        undoAnswer() {
            if (!this.undoSnap) return;
            clearTimeout(this._undoTimer);
            const snap = this.undoSnap;
            // Restore SRS word state
            if (snap.prevState) {
                this.$set(this.state, snap.wordId, snap.prevState);
            } else {
                this.$delete(this.state, snap.wordId);
            }
            // Restore counters
            this.points         = snap.points;
            this.streak         = snap.streak;
            this.totalReviewed  = snap.totalReviewed;
            this.sessionCorrect = snap.sessionCorrect;
            // Put card back at front of queue
            const card = this.allWords.find(w => w.word === snap.wordId);
            if (card) {
                const idx = this.queue.indexOf(card);
                if (idx !== -1) this.queue.splice(idx, 1);
                this.queue.unshift(card);
            }
            this.flipped  = false;
            this.showUndo = false;
            this.undoSnap = null;
            this.saveState();
            this.saveGlobal();
        },

        // ── Word list modal ──────────────────────────────────────────
        showWordList(stageGroup) {
            const STAGE_GROUPS = {
                new:      s => !s || s.stage === 'new',
                learn:    s => s && (s.stage === 'learning' || s.stage === 'relearn' || s.stage === 'young'),
                review:   s => s && s.stage === 'mature',
                mastered: s => s && s.stage === 'mastered',
            };
            const filter = STAGE_GROUPS[stageGroup];
            const words = this.allWords.filter(w => filter(this.state[w.word]));
            const titles = {
                new:      this.ui.wlNew,
                learn:    this.ui.wlLearn,
                review:   this.ui.wlReview,
                mastered: this.ui.wlMastered,
            };
            this.wordListModal = { stageGroup, title: titles[stageGroup], words };
        },
        closeWordList() { this.wordListModal = null; },

        // ── Reading overlay ─────────────────────────────────────────
        openReading() {
            this.readingHistoryOpen = false;
            this.readingError       = '';
            this.readingOpen        = true;
            if (this.geminiKey) {
                // Serve cached article for today + current deck without re-generating
                const tdy    = today();
                const cached = this.readingHistory.find(
                    e => e.date === tdy && e.deckId === this.currentDeck.id);
                if (cached) {
                    this.readingWordObjs = cached.words.map(
                        w => this.allWords.find(aw => aw.word === w.word) || w);
                    this.readingArticle  = cached.text;
                } else {
                    this.readingArticle = '';
                    this.readingLoading = true;
                    this.generateReading();
                }
            }
        },
        saveGeminiKey() {
            const k = this.geminiKeyInput.trim();
            if (!k) return;
            this.geminiKey = k;
            localStorage.setItem('gemini_key', k);
            this.geminiKeyInput = '';
            this.readingLoading = true;
            this.generateReading();
        },
        closeReading() {
            this.readingOpen        = false;
            this.readingArticle     = '';
            this.readingError       = '';
            this.readingLoading     = false;
            this.readingHistoryOpen = false;
        },
        openHistoryItem(entry) {
            this.readingWordObjs    = entry.words.map(
                w => this.allWords.find(aw => aw.word === w.word) || w);
            this.readingArticle     = entry.text;
            this.readingHistoryOpen = false;
            this.readingError       = '';
        },
        saveReadingHistory(text) {
            const entry = {
                id:     Date.now(),
                date:   today(),
                deckId: this.currentDeck.id,
                words:  this.readingWordObjs.map(w => ({ word: w.word, zh: w.zh })),
                text,
            };
            this.readingHistory.unshift(entry);
            if (this.readingHistory.length > 30)
                this.readingHistory = this.readingHistory.slice(0, 30);
            localStorage.setItem('reading_history', JSON.stringify(this.readingHistory));
            // Silent sync reading history to cloud
            if (window.__vocabSync && window.__vocabSync.push) window.__vocabSync.push();
        },
        async pasteApiKey() {
            try {
                const text = await navigator.clipboard.readText();
                if (text) this.geminiKeyInput = text.trim();
            } catch (_) { /* clipboard permission denied — user pastes manually */ }
        },
        // Tap on a highlighted vocab word → show its Chinese meaning as a toast
        onVocabHlClick(e) {
            const word = e.target.dataset && e.target.dataset.word;
            if (!word) return;
            const wobj = this.readingWordObjs.find(w =>
                w.word.toLowerCase() === word.toLowerCase());
            if (wobj) this.showToast(`${wobj.word}：${wobj.zh}`, 'good');
        },
        async generateReading() {
            const GEMINI_KEY = this.geminiKey;
            const tdy = today();
            const MAX_READING_WORDS = 20;
            // Priority 1: words first seen today (newly entered learning)
            const newToday = this.allWords.filter(w => {
                const s = this.state[w.word];
                return s && s.firstSeen === tdy;
            });
            // Priority 2: Young stage (interval established but still fresh)
            const youngWords = this.allWords.filter(w => {
                const s = this.state[w.word];
                return s && s.stage === 'young' && s.firstSeen !== tdy;
            }).sort((a, b) => (this.state[a.word].interval || 0) - (this.state[b.word].interval || 0));
            // Priority 3: Learning stage
            const learningWords = this.allWords.filter(w => {
                const s = this.state[w.word];
                return s && s.stage === 'learning' && s.firstSeen !== tdy;
            });
            let selected = [...newToday];
            if (selected.length < MAX_READING_WORDS)
                selected = [...selected, ...youngWords].slice(0, MAX_READING_WORDS);
            if (selected.length < MAX_READING_WORDS)
                selected = [...selected, ...learningWords].slice(0, MAX_READING_WORDS);
            if (selected.length === 0)
                selected = this.getTodayPracticeWords().slice(0, MAX_READING_WORDS);
            this.readingWordObjs = selected.slice(0, MAX_READING_WORDS);
            const wordList = this.readingWordObjs
                .map(w => `${w.word} (${w.zh})`).join(', ');
            const prompt = `You are a creative writing tutor crafting a short story to help an intermediate English learner remember new vocabulary.\n\nRequirements:\n- Length: 180–220 words.\n- Weave ALL of the vocabulary words below naturally into the story — they should feel essential, not forced.\n- Literary quality: give the story a clear arc (setup → tension → resolution), a vivid scene, and at least one moment of emotion or surprise that makes it memorable.\n- Vocabulary level: keep all OTHER words at roughly the same difficulty as the given list — don't simplify to beginner level, but avoid obscure words the learner hasn't seen.\n- Tone: warm, imaginative, slightly literary — think short-story rather than textbook exercise.\n- Return only the story text. No title, no commentary, no word list.\n\nVocabulary: ${wordList}`;

            this.readingLoading = true;
            this.readingArticle = '';
            this.readingError   = '';

            const controller = new AbortController();
            const timeoutId  = setTimeout(() => controller.abort(), 18000);
            try {
                const res = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_KEY}`,
                    {
                        method:  'POST',
                        headers: { 'Content-Type': 'application/json' },
                        signal:  controller.signal,
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { maxOutputTokens: 800, temperature: 0.9, thinkingConfig: { thinkingBudget: 0 } }
                        })
                    }
                );
                clearTimeout(timeoutId);
                if (!res.ok) {
                    const status = res.status;
                    let apiMsg = '';
                    try { const e = await res.json(); apiMsg = e.error?.message || ''; } catch (_) {}
                    if (status === 429) throw { _type: 'rate_limit' };
                    if (status === 403) throw { _type: 'key_error', msg: apiMsg };
                    throw { _type: 'generic', msg: `HTTP ${status}${apiMsg ? ': ' + apiMsg : ''}` };
                }
                const data = await res.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                if (!text) throw { _type: 'generic' };
                this.readingArticle = text.trim();
                this.saveReadingHistory(text.trim());
            } catch (e) {
                clearTimeout(timeoutId);
                if (e.name === 'AbortError') {
                    this.readingError = this.ui.readingErrTime;
                } else if (e._type === 'rate_limit') {
                    this.readingError = this.ui.readingErr429;
                } else if (e._type === 'key_error') {
                    this.readingError = this.ui.readingErrKey + (e.msg ? '\n' + e.msg : '');
                } else if (e instanceof TypeError || !navigator.onLine) {
                    this.readingError = this.ui.readingErrNet;
                } else {
                    this.readingError = (e.msg || this.ui.readingError);
                }
            } finally {
                this.readingLoading = false;
            }
        },

        selectMatchLeft(key) {
            if (this.matchElim.includes(key)) return;
            this.matchSelLeft = (this.matchSelLeft === key) ? null : key;
        },
        selectMatchRight(key) {
            if (!this.matchSelLeft || this.matchElim.includes(key)) return;
            if (this.matchSelLeft === key) {
                // Correct pair
                this.matchElim = [...this.matchElim, key];
                this.matchSelLeft = null;
                playFeedbackSound('correct');
                if (this.matchElim.length === this.practiceCurrent.pairs.length) {
                    // All matched — count as correct, auto-advance
                    this.practiceScore++;
                    this.practiceAnswered = true;
                    clearTimeout(this._practiceTimer);
                    this._practiceTimer = setTimeout(() => this.nextPracticeQuestion(), 1200);
                }
            } else {
                // Wrong pair — shake both, track wrong word
                const leftKey = this.matchSelLeft;
                this.matchShakeKeys = [leftKey, key];
                setTimeout(() => { this.matchShakeKeys = []; }, 400);
                const wobj = this.practiceCurrent.pairs.find(p => p.word === leftKey);
                if (wobj && !this.practiceWrongWords.some(w => w.word === wobj.word)) {
                    this.practiceWrongWords.push(wobj);
                }
                this.matchSelLeft = null;
                playFeedbackSound('wrong');
            }
        },
        submitPracticeAnswer(val) {
            if (this.practiceAnswered || !this.practiceCurrent) return;
            const norm      = s => s.toLowerCase().trim();
            const isCorrect = norm(String(val)) === norm(this.practiceCurrent.correct);
            this.practiceSelected = String(val);
            this.practiceResult   = isCorrect ? 'correct' : 'wrong';
            this.practiceAnswered = true;
            if (isCorrect) {
                this.practiceScore++;
                if (this.autoPlay) {
                    setTimeout(() => this.playAudio(this.practiceCurrent.word.word), 300);
                }
                playFeedbackSound('correct');
            } else {
                // Deduplicate — same word may appear in multiple question types
                const wobj = this.practiceCurrent.word;
                if (!this.practiceWrongWords.some(w => w.word === wobj.word)) {
                    this.practiceWrongWords.push(wobj);
                }
                playFeedbackSound('wrong');
            }
            // Auto-advance: faster when correct (1.4s), longer when wrong (2.6s) to read correct answer
            clearTimeout(this._practiceTimer);
            this._practiceTimer = setTimeout(() => this.nextPracticeQuestion(), isCorrect ? 1400 : 2600);
        },

        nextPracticeQuestion() {
            clearTimeout(this._practiceTimer);
            const next = this.practiceIndex + 1;
            if (next >= this.practiceQueue.length) {
                this.practiceDone = true;
                return;
            }
            this.practiceIndex    = next;
            this.practiceAnswered = false;
            this.practiceSelected = null;
            this.practiceInput    = '';
            this.practiceResult   = null;
            this.matchSelLeft     = null;
            this.matchElim        = [];
            this.matchShakeKeys   = [];
            this._afterPracticeQuestion();
        },

        /** Side-effects after a new practice question is shown */
        _afterPracticeQuestion() {
            const q = this.practiceCurrent;
            if (!q) return;
            this.$nextTick(() => {
                if (q.type === 'mc-audio-to-word') {
                    this.playAudio(q.word.word);
                } else if (q.type === 'spelling' && this.$refs.spellInput) {
                    this.$refs.spellInput.focus();
                }
            });
        },

        // ── Keyboard ─────────────────────────────────────────────────────
        onKey(e) {
            if (this.loading) return;
            const tag = document.activeElement && document.activeElement.tagName;

            // ── Practice mode keyboard shortcuts ──────────────────────────
            if (this.practiceMode && !this.practiceDone) {
                const q = this.practiceCurrent;
                if (!q) return;
                // After answering: Enter / Space / arrow advances to next question
                if (this.practiceAnswered) {
                    if (['Enter','Space','ArrowRight'].includes(e.code)) {
                        e.preventDefault();
                        clearTimeout(this._practiceTimer);
                        this.nextPracticeQuestion();
                    }
                    return;
                }
                // Active questions (ignore when typing in an input)
                if (tag === 'INPUT' || tag === 'TEXTAREA') return;
                const isMC = q.type !== 'spelling' && q.type !== 'truefalse' && q.type !== 'matching';
                if (isMC) {
                    const idx = ['Digit1','Digit2','Digit3','Digit4'].indexOf(e.code);
                    if (idx !== -1 && idx < (q.options || []).length) {
                        e.preventDefault();
                        this.submitPracticeAnswer(q.options[idx].value);
                    }
                } else if (q.type === 'truefalse') {
                    if (e.code === 'KeyT') { e.preventDefault(); this.submitPracticeAnswer('true'); }
                    if (e.code === 'KeyF') { e.preventDefault(); this.submitPracticeAnswer('false'); }
                    if (e.code === 'Digit1' || e.code === 'ArrowLeft') { e.preventDefault(); this.submitPracticeAnswer('true'); }
                    if (e.code === 'Digit2' || e.code === 'ArrowRight') { e.preventDefault(); this.submitPracticeAnswer('false'); }
                }
                return;
            }

            if (this.sessionDone) return;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'BUTTON') return;

            if (e.code === 'Space') {
                e.preventDefault();
                this.flipCard();
                return;
            }
            if (e.code === 'KeyP') {
                this.playAudio(this.cur.word);
                return;
            }
            const arrowMap = {
                ArrowLeft: 'again', ArrowDown: 'hard',
                ArrowRight: 'good', ArrowUp:   'easy',
            };
            if (arrowMap[e.code]) {
                e.preventDefault();
                if (this.flipped) this.answer(arrowMap[e.code]);
                else              this.flipCard();
            }
        },
    },

    created() {
        // Non-reactive caches (avoid Vue reactivity overhead on Audio/timer objects)
        this._audioPreloads  = {};   // word -> preloaded Audio element
        this._prefetchTimers = [];   // pending staggered preload timers
        // Restore preferred deck before loading state
        const savedDeckId = localStorage.getItem(DECK_PREF_KEY);
        if (savedDeckId) {
            const found = DECKS.find(d => d.id === savedDeckId);
            if (found) this.currentDeck = found;
        }
        this.loadSaved();
        this.loadGlobal();
        this.loadDictCache();
        this.loadWords();
    },
    mounted() {
        window.addEventListener('keydown', this.onKey);
        // Pre-load TTS voice list (async on some browsers; fire-and-forget)
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.addEventListener('voiceschanged', () => speechSynthesis.getVoices());
        }
        // Save when user switches tabs / goes to background on mobile
        this._onVisibility = () => {
            if (document.hidden) {
                this.saveState();
                this.saveGlobal();
            }
        };
        document.addEventListener('visibilitychange', this._onVisibility);

        // Detect if Node.js backend API is available
        this.checkBackend();
    },
    beforeDestroy() {
        window.removeEventListener('keydown', this.onKey);
        document.removeEventListener('visibilitychange', this._onVisibility);
    },
});
</script>

<!-- ── PWA Install Prompts ──────────────────────────────────────────────── -->
<script>
(function () {
    // Populate i18n text (UI is defined in the main script block above)
    document.getElementById('pwa-android-desc').textContent = UI.pwaAndroidDesc;
    document.getElementById('pwa-install-btn').textContent  = UI.pwaAndroidInstall;
    document.getElementById('pwa-ios-title').textContent    = UI.pwaIOSTitle;
    document.getElementById('pwa-ios-desc').textContent     = UI.pwaIOSDesc;
    document.getElementById('pwa-step1').innerHTML          = UI.pwaIOSStep1;
    document.getElementById('pwa-step2').innerHTML          = UI.pwaIOSStep2;
    document.getElementById('pwa-step3').innerHTML          = UI.pwaIOSStep3;
    document.getElementById('pwa-dismiss-ios').textContent  = UI.pwaIOSDismiss;

    const SHOWN_KEY = 'pwa_prompt_shown_v1';

    // ── Helper: is this already running as a standalone PWA? ──────────────
    function isStandalone() {
        return window.matchMedia('(display-mode: standalone)').matches
            || window.navigator.standalone === true;   // iOS
    }

    if (isStandalone()) return;   // already installed → skip everything

    // ── Detect platform ───────────────────────────────────────────────────
    const ua  = navigator.userAgent;
    const isIOS     = /iphone|ipad|ipod/i.test(ua);
    const isSafari  = /safari/i.test(ua) && !/chrome|crios|fxios/i.test(ua);
    const isAndroid = /android/i.test(ua);

    // ── iOS: show guide after a 2 s delay on first visit ─────────────────
    if (isIOS && isSafari && !localStorage.getItem(SHOWN_KEY)) {
        const overlay  = document.getElementById('pwa-ios');
        const dismissBtn = document.getElementById('pwa-dismiss-ios');

        setTimeout(function () {
            overlay.classList.add('show');
        }, 2000);

        dismissBtn.addEventListener('click', function () {
            overlay.classList.remove('show');
            localStorage.setItem(SHOWN_KEY, '1');
        });

        // Also dismiss on backdrop tap
        overlay.addEventListener('click', function (e) {
            if (e.target === overlay) {
                overlay.classList.remove('show');
                localStorage.setItem(SHOWN_KEY, '1');
            }
        });
        return;
    }

    // ── Android / Chrome: capture beforeinstallprompt ─────────────────────
    let deferredPrompt = null;
    const banner     = document.getElementById('pwa-android');
    const installBtn = document.getElementById('pwa-install-btn');
    const dismissBtn = document.getElementById('pwa-dismiss-android');

    window.addEventListener('beforeinstallprompt', function (e) {
        e.preventDefault();
        deferredPrompt = e;

        if (localStorage.getItem(SHOWN_KEY)) return;   // dismissed before

        setTimeout(function () {
            banner.classList.add('show');
        }, 2500);
    });

    installBtn.addEventListener('click', async function () {
        if (!deferredPrompt) return;
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;
        banner.classList.remove('show');
        localStorage.setItem(SHOWN_KEY, '1');
    });

    dismissBtn.addEventListener('click', function () {
        banner.classList.remove('show');
        localStorage.setItem(SHOWN_KEY, '1');
    });

    // Hide banner once installed
    window.addEventListener('appinstalled', function () {
        banner.classList.remove('show');
    });
})();
</script>

<!-- ── Force-refresh interaction ────────────────────────────────────────── -->
<script>
(function () {
    const zh   = document.documentElement.lang === 'zh';
    const btn  = document.getElementById('upd-btn');
    const ring = btn.querySelector('.upd-ring');
    const txt  = btn.querySelector('.upd-txt');

    txt.textContent = zh ? '检查更新' : 'Check for updates';

    const steps = zh
        ? ['正在检查…', '3', '2', '1', '🚀 起飞！']
        : ['Checking…',  '3', '2', '1', '🚀 Launch!'];

    let busy = false;
    btn.addEventListener('click', function () {
        if (busy) return;
        busy = true;
        btn.classList.add('upd-go');
        txt.textContent = steps[0];

        let i = 0;
        const tick = setInterval(function () {
            i++;
            if (i < steps.length - 1) {
                txt.textContent = steps[i];
            } else {
                clearInterval(tick);
                ring.style.animation = 'none';
                ring.textContent = '🚀';
                txt.textContent = steps[steps.length - 1];
                btn.classList.remove('upd-go');
                btn.classList.add('upd-blast');
                setTimeout(function () {
                    window.location.reload(true);
                }, 420);
            }
        }, 520);
    });
})();
</script>
<script>
(function(){
  function setAccountLabel(){
    // Only show username when backend is available (Vue will handle button visibility)
    if(!window.__backendAvailable) return;
    try{
      const btn = document.getElementById('accountBtn');
      if(!btn) return;
      const raw = localStorage.getItem('vocabloop_auth');
      if(!raw) return;
      const auth = JSON.parse(raw);
      if(auth && auth.username){
        btn.textContent = auth.username;
        btn.title = 'Account: ' + auth.username;
      }
    }catch(_e){}
  }
  // Defer until Vue has finished backend detection
  function trySetLabel(){
    if(window.__backendAvailable !== undefined) { setAccountLabel(); return; }
    setTimeout(trySetLabel, 200);
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(trySetLabel, 300); });
  }else{
    setTimeout(trySetLabel, 300);
  }
})();
</script>

<!-- ── Cloud Sync Module ───────────────────────────────────────────────── -->
<script>
(function(){
  'use strict';

  /* ── Refs ── */
  const SYNC_TS_KEY  = 'vocabloop_sync_ts';   // last successful sync timestamp
  const DECK_IDS     = ['pet', 'daily', 'ielts', 'crypto'];
  const GLOBAL_KEY   = 'srs_global_v1';
  const DECK_PREF    = 'preferred_deck';
  const DEBOUNCE_MS  = 3000;   // debounce push after save
  let _debounceTimer = null;
  let _syncing       = false;

  /* ── Helpers ── */
  function getAuth(){
    try{ return JSON.parse(localStorage.getItem('vocabloop_auth')); } catch(e){ return null; }
  }

  function getSyncBtn(){ return document.getElementById('syncBtn'); }

  function setSyncState(state){
    const btn = getSyncBtn();
    if(!btn) return;
    btn.classList.remove('syncing', 'sync-ok');
    if(state === 'syncing') btn.classList.add('syncing');
    if(state === 'done')    btn.classList.add('sync-ok');
    if(state === 'done'){
      setTimeout(function(){ btn.classList.remove('sync-ok'); }, 2000);
    }
  }

  /** Collect all syncable data from localStorage */
  function collectLocal(){
    const decks = {};
    for(const id of DECK_IDS){
      try{
        const raw = localStorage.getItem('srs_' + id + '_v1');
        if(raw) decks[id] = JSON.parse(raw);
      } catch(e){}
    }
    let global = {};
    try{
      const raw = localStorage.getItem(GLOBAL_KEY);
      if(raw) global = JSON.parse(raw);
    } catch(e){}

    let readingHistory = [];
    try{
      const raw = localStorage.getItem('reading_history');
      if(raw) readingHistory = JSON.parse(raw);
    } catch(e){}

    return {
      decks:          decks,
      global:         global,
      preferredDeck:  localStorage.getItem(DECK_PREF) || '',
      readingHistory: readingHistory,
    };
  }

  /** Apply merged cloud data back to localStorage and reload Vue state */
  function applyData(data){
    if(!data) return;

    // Write deck states
    if(data.decks){
      for(const id of DECK_IDS){
        if(data.decks[id]){
          try{ localStorage.setItem('srs_' + id + '_v1', JSON.stringify(data.decks[id])); } catch(e){}
        }
      }
    }

    // Write global state
    if(data.global){
      try{ localStorage.setItem(GLOBAL_KEY, JSON.stringify(data.global)); } catch(e){}
    }

    // Write preferred deck
    if(data.preferredDeck){
      try{ localStorage.setItem(DECK_PREF, data.preferredDeck); } catch(e){}
    }

    // Write reading history
    if(Array.isArray(data.readingHistory)){
      try{ localStorage.setItem('reading_history', JSON.stringify(data.readingHistory)); } catch(e){}
    }

    // Record sync timestamp
    try{ localStorage.setItem(SYNC_TS_KEY, String(Date.now())); } catch(e){}
  }

  /** Reload the Vue app's in-memory state from localStorage (if Vue app exists) */
  function reloadVueState(){
    var app = document.getElementById('app');
    if(app && app.__vue__){
      var vm = app.__vue__;
      vm.loadSaved();
      vm.loadGlobal();
      vm.buildQueue();
    }
  }

  /** Call the sync API */
  async function callSync(payload){
    const r = await fetch('/api/sync', {
      method: 'POST',
      headers: {'content-type':'application/json'},
      body: JSON.stringify(payload),
    });
    return r.json();
  }

  /**
   * Full sync: merge local with cloud, apply result.
   * Returns true on success.
   */
  async function doSync(){
    const auth = getAuth();
    if(!auth || !auth.token) return false;
    if(_syncing) return false;
    _syncing = true;
    setSyncState('syncing');

    try{
      const localData = collectLocal();
      const result = await callSync({
        action: 'merge',
        token:  auth.token,
        data:   localData,
      });

      if(result.ok && result.data){
        applyData(result.data);
        reloadVueState();
        setSyncState('done');
        return true;
      } else {
        setSyncState('');
        // Token expired or invalid — clear stored auth so user is prompted to re-login
        if(result.message && (result.message.includes('Invalid or expired') || result.message.includes('expired'))) {
          try { localStorage.removeItem('vocabloop_auth'); } catch(_){}
          return 'token_expired';
        }
        return false;
      }
    } catch(e){
      setSyncState('');
      return false;
    } finally {
      _syncing = false;
    }
  }

  /**
   * Push-only sync (debounced): upload local data to cloud without pulling.
   * Used after each saveState/saveGlobal call.
   */
  async function debouncedPush(){
    const auth = getAuth();
    if(!auth || !auth.token) return;
    clearTimeout(_debounceTimer);
    _debounceTimer = setTimeout(async function(){
      if(_syncing) return;
      _syncing = true;
      setSyncState('syncing');
      try{
        const localData = collectLocal();
        const result = await callSync({
          action: 'push',
          token:  auth.token,
          data:   localData,
        });
        if(result.ok){
          try{ localStorage.setItem(SYNC_TS_KEY, String(Date.now())); } catch(e){}
          setSyncState('done');
        } else {
          setSyncState('');
        }
      } catch(e){
        setSyncState('');
      } finally {
        _syncing = false;
      }
    }, DEBOUNCE_MS);
  }

  /**
   * Manual sync (triggered by sync button click).
   */
  async function manualSync(){
    var auth = getAuth();
    if(!auth || !auth.token){
      // Show toast via Vue app if possible
      var app = document.getElementById('app');
      if(app && app.__vue__ && app.__vue__.showToast){
        app.__vue__.showToast(typeof UI !== 'undefined' ? UI.syncNoAccount : 'Please log in first', 'bad');
      }
      return;
    }
    var result = await doSync();
    var app = document.getElementById('app');
    if(app && app.__vue__ && app.__vue__.showToast){
      if(result === true)             app.__vue__.showToast(typeof UI !== 'undefined' ? UI.syncDone : 'Synced!', 'good');
      else if(result === 'token_expired') {
        app.__vue__.showToast(typeof UI !== 'undefined' ? UI.syncTokenExpired : 'Session expired, please log in again', 'bad');
        // Redirect to account page after a short delay so user sees the toast
        setTimeout(function(){ window.location.href = 'account.html'; }, 1800);
      } else                          app.__vue__.showToast(typeof UI !== 'undefined' ? UI.syncFail : 'Sync failed', 'bad');
    }
  }

  /* ── Hook into Vue app's save methods ── */
  function hookSaveState(){
    var app = document.getElementById('app');
    if(!app || !app.__vue__) return;
    var vm = app.__vue__;

    // Wrap saveState
    var origSave = vm.saveState.bind(vm);
    vm.saveState = function(){
      origSave();
      debouncedPush();
    };

    // Wrap saveGlobal
    var origGlobal = vm.saveGlobal.bind(vm);
    vm.saveGlobal = function(){
      origGlobal();
      // Push is already debounced, so calling again just resets the timer
      debouncedPush();
    };
  }

  /* ── Auto-sync on page load if logged in ── */
  function init(){
    // Skip sync initialization when backend is not available (static hosting)
    if(!window.__backendAvailable) return;
    var auth = getAuth();
    if(auth && auth.token){
      // Sync on load (merge cloud + local)
      doSync().then(function(){
        // After initial sync, hook save methods for auto-push
        hookSaveState();
      });
    } else {
      // Not logged in — just hook saves in case they log in later (no-op push without token)
      hookSaveState();
    }
  }

  /* ── Sync when returning to app from background ── */
  document.addEventListener('visibilitychange', function(){
    if(!document.hidden && window.__backendAvailable){
      var auth = getAuth();
      if(auth && auth.token) doSync();
    }
  });

  /* ── Expose for manual trigger & silent push ── */
  window.__vocabSync = { manualSync: manualSync, doSync: doSync, push: debouncedPush };

  /* ── Start — wait for backend detection before initializing ── */
  function waitAndInit(){
    if(window.__backendAvailable !== undefined){ setTimeout(init, 100); return; }
    setTimeout(waitAndInit, 200);
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(waitAndInit, 300); });
  } else {
    setTimeout(waitAndInit, 300);
  }

})();
</script>
</body>
</html>
